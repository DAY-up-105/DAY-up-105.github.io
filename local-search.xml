<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>操作系统_Chapter3</title>
    <link href="/2022/09/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Chapter3/"/>
    <url>/2022/09/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Chapter3/</url>
    
    <content type="html"><![CDATA[<h2 id="第3章-进程描述和控制"><a href="#第3章-进程描述和控制" class="headerlink" title="第3章 进程描述和控制"></a>第3章 进程描述和控制</h2><ul><li>操作系统的多数需求都涉及进程：<ul><li>与普通计算机软件作用相同，是由处理器执行的一段程序或一组程序</li><li>必须交替执行多个进程，在合理的响应时间范围内使处理器的利用率最大</li><li>必须按照特定的策略给进程分配资源，同时避免死锁</li><li>为有助于构建应用的进程间通信和用户进程创建提供支持</li></ul></li></ul><h3 id="3-1-什么是进程"><a href="#3-1-什么是进程" class="headerlink" title="3.1 什么是进程"></a>3.1 什么是进程</h3><h4 id="3-1-1-背景"><a href="#3-1-1-背景" class="headerlink" title="3.1.1 背景"></a>3.1.1 背景</h4><ul><li>操作系统需要达到的目标：<ul><li>资源对多个应用程序可用</li><li>处理器在多个程序间切换，保证所有程序都在执行中</li><li>处理器和I&#x2F;O设备得到充分利用</li></ul></li></ul><h4 id="3-1-2-进程和进程控制块"><a href="#3-1-2-进程和进程控制块" class="headerlink" title="3.1.2 进程和进程控制块"></a>3.1.2 进程和进程控制块</h4><ul><li>进程的几个定义：<ul><li>一个正在执行的程序</li><li>一个正在计算机上执行的程序实例</li><li>能分配给处理器并由处理器执行的实体</li><li>由一组执行的指令、一个当前状态和一组相关的系统资源表征的活动单元</li></ul></li><li>进程&#x3D;程序+执行，可由如下元素表征：<ul><li>标识符</li><li>状态</li><li>优先级</li><li>程序计数器（PC）</li><li>内存指针</li><li>上下文数据</li><li>I&#x2F;O状态信息</li><li>记账信息（处理器时间总和、使用的时钟数总和等）</li></ul></li><li><strong>进程控制块（process control block，PCB）</strong>：保存上述列表信息，由操作系统创建和管理</li></ul><h3 id="3-2-进程状态"><a href="#3-2-进程状态" class="headerlink" title="3.2 进程状态"></a>3.2 进程状态</h3><ul><li>列出为进程执行的指令序列，可描述单个进程的行为，这样的序列称为进程<strong>轨迹（trace）</strong></li><li>分派器（scheduler）：使处理器切换进程</li></ul><h4 id="3-2-1-两状态进程模型"><a href="#3-2-1-两状态进程模型" class="headerlink" title="3.2.1 两状态进程模型"></a>3.2.1 两状态进程模型</h4><ul><li><img src="/.com//image-20220910100055215.png" alt="image-20220910100055215"></li><li>进程被分为运行态和非运行态</li><li><img src="/.com//image-20220910100118292.png" alt="image-20220910100118292"></li><li>用排队图描述分派器的行为：当一个处于运行态的进程终止后，我们就要选一个处于非运行态的进程进入运行态</li></ul><h4 id="3-2-2-进程的创建和终止"><a href="#3-2-2-进程的创建和终止" class="headerlink" title="3.2.2 进程的创建和终止"></a>3.2.2 进程的创建和终止</h4><ul><li><p><strong>进程的创建</strong>：操作系统建立用于管理该进程的数据结构，并在内存中分配地址空间</p></li><li><p>创建进程的原因：</p><table><thead><tr><th>事件</th><th>说明</th></tr></thead><tbody><tr><td>新的批处理作业</td><td>磁带中的批处理作业控制流通常会提供给操作系统，当操作系统准备接收新工作时，将读取下一个作业控制命令</td></tr><tr><td>交互登录</td><td>终端用户登录到系统</td></tr><tr><td>为提供服务</td><td>操作系统创建一个进程，代表用户程序执行一个功能，使用户无需等待</td></tr><tr><td>由现有进程派生</td><td>基于模块化的考虑或开发并行性，用户程序可以指示创建多个进程</td></tr></tbody></table></li><li><p><strong>进程派生（process spawing）</strong>：操作系统为另一个进程显式请求创建一个进程的动作。（原进程为父进程，被派生的进程为子进程）</p></li><li><p><strong>进程终止</strong>：操作系统发出一个服务请求，以终止发出请求的进程。</p></li><li><p>导致进程终止的原因：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">正常完成超过时限无可用内存超出范围保护错误<br>算术错误时间超出<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>失败  无效指令  特权指令<br>数据误用操作员或操作系统干涉父进程终止父进程请求<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-2-3-五状态模型"><a href="#3-2-3-五状态模型" class="headerlink" title="3.2.3 五状态模型"></a>3.2.3 五状态模型</h4><ul><li><p>两状态的问题：存在一些处于非运行态但已就绪等待执行的进程，也存在一些处于阻塞态等待I&#x2F;O操作结束的进程</p></li><li><p>因此，若使用单个队列，分派器不能只考虑选择队列中最老的进程，而是扫描列表，查找未被阻塞且在队列中时间最长的进程</p></li><li><p>办法：将非运行态分成两个状态：<strong>就绪态（ready）</strong>和<strong>阻塞态（blocked）</strong></p></li><li><p><img src="/.com//image-20220910100136847.png" alt="image-20220910100136847"></p><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>运行态</td><td>进程正在执行</td></tr><tr><td>就绪态</td><td>进程已准备好，只要有机会就开始执行</td></tr><tr><td>阻塞&#x2F;等待态</td><td>进程在某些事件发生前不能执行</td></tr><tr><td>新建态</td><td>刚刚创建的进程，还未加入到可执行进程组（进程控制块已创建但还未加载到内存中的新进程）</td></tr><tr><td>退出态</td><td>从可执行进程组释放出的进程（自身停止或被取消）</td></tr></tbody></table></li></ul><h4 id="3-2-4-被挂起的进程"><a href="#3-2-4-被挂起的进程" class="headerlink" title="3.2.4 被挂起的进程"></a>3.2.4 被挂起的进程</h4><ul><li><p>交换：把内存中某个进程的一部分或全部移到磁盘中，当内存中不存在就绪态的进程时，操作系统就把被阻塞的进程换到磁盘中的挂起队列（suspend queue）</p></li><li><p><strong>挂起态（suspend）</strong>：内存中所有进程都处于阻塞态时，操作系统可把其中的一个进程置为挂起态，并把它转移到磁盘，此时内存所释放的空间就可被调入的另一个进程使用</p></li><li><p><img src="/.com//image-20220910100148367.png" alt="image-20220910100148367"></p><ul><li>就绪态：进程已在内存中并可以执行</li><li>阻塞态：进程已在内存中并等待一个事件</li><li>阻塞&#x2F;挂起态：进程已在外存中并等待一个事件</li><li>就绪&#x2F;挂起态：进程已在外存中，但只要载入内存就可执行</li></ul></li><li><p>进程挂起的原因：</p><table><thead><tr><th>事件</th><th>说明</th></tr></thead><tbody><tr><td>交换</td><td>操作系统需要释放足够的内存空间，以调入并执行处于就绪态的进程</td></tr><tr><td>其他OS原因</td><td>操作系统可能挂起后台进程或工具程序进程，或挂起可能会导致问题的进程</td></tr><tr><td>交互式用户请求</td><td>用户希望挂起一个程序的执行，以便调试或关联资源的使用</td></tr><tr><td>定时</td><td>进程可被周期性地执行，并在等待下一个时间间隔时挂起</td></tr><tr><td>父进程请求</td><td>父进程可能会希望挂起后代进程的执行，以检查或修改挂起的进程，或协调不同后代进程之间的行为</td></tr></tbody></table></li></ul><h3 id="3-3-进程描述"><a href="#3-3-进程描述" class="headerlink" title="3.3 进程描述"></a>3.3 进程描述</h3><h4 id="3-3-1-操作系统的控制结构"><a href="#3-3-1-操作系统的控制结构" class="headerlink" title="3.3.1 操作系统的控制结构"></a>3.3.1 操作系统的控制结构</h4><ul><li>操作系统构造并维护四种信息表以掌握每个进程和资源的当前状态：内存、I&#x2F;O、文件和进程</li><li>**内存表（memory table)**：用于跟踪内存和外存。包含以下信息：<ul><li>分配给进程的内存</li><li>分配给进程的外存</li><li>内存块或虚存块的任何保护属性</li><li>管理虚存所需要的任何信息</li></ul></li><li><strong>I&#x2F;O表</strong>：管理计算机系统中的I&#x2F;O设备和通道：</li><li><strong>文件表（file table）</strong>：提供关于文件是否存在、文件在外存中的位置、当前状态和其他属性的信息</li><li><strong>进程表（process tables）</strong>：必须有对内存、I&#x2F;O、文件的直接或间接引用</li></ul><h4 id="3-3-2-进程控制结构"><a href="#3-3-2-进程控制结构" class="headerlink" title="3.3.2 进程控制结构"></a>3.3.2 进程控制结构</h4><ul><li><p><strong>进程映像（process image）</strong>：程序、数据、栈和属性（PCB）的集合</p><table><thead><tr><th>元素</th><th>说明</th></tr></thead><tbody><tr><td>用户数据</td><td>可修改的部分，包括程序数据、用户栈区域和可修改的程序</td></tr><tr><td>用户程序</td><td>待执行的程序</td></tr><tr><td>栈</td><td>每个进程有至少一个后进先出栈，用于保存参数、过程调用地址和系统调用地址</td></tr><tr><td>进程控制块</td><td>操作系统控制进程所需的数据</td></tr></tbody></table></li><li><p>进程控制块信息分为三类：</p><ul><li>进程标识信息</li><li>进程状态信息</li><li>进程控制信息</li></ul></li><li><p>对所有操作系统中的<strong>进程标识符（process identification）</strong>来说，每个进程都分配了一个唯一的数字标识符，包括：</p><ul><li>该进程的标识符（Process ID）</li><li>父进程的标识符</li><li>用户标识符（User ID）</li></ul></li><li><p><strong>处理器状态信息（processor state information）</strong>由处理器寄存器的内容组成，通常包括：</p><ul><li>用户可见寄存器：用户模式下执行时可访问的寄存器</li><li>控制和状态寄存器：程序计数器、<strong>程序状态字（Program State Word，PSW）</strong>（通常包含条件码、状态信息）</li><li>栈指针：指向栈顶</li></ul></li><li><p><strong>进程控制信息（process control information）</strong>是操作系统控制和协调各种活动进程所需要的额外信息</p><ul><li>调度和状态信息：进程状态、优先级、调度相关信息、事件</li><li>数据结构：进程可以以队列等结构链接到其他进程</li><li>进程间通信</li><li>进程特权</li><li>存储管理</li><li>资源所有权和使用情况</li></ul></li><li><p>进程控制块的作用：操作系统中最重要的数据结构。每个PCB都包含操作系统所需进程的所有信息</p></li></ul><h3 id="3-4-进程控制"><a href="#3-4-进程控制" class="headerlink" title="3.4 进程控制"></a>3.4 进程控制</h3><h4 id="3-4-1-执行模式"><a href="#3-4-1-执行模式" class="headerlink" title="3.4.1 执行模式"></a>3.4.1 执行模式</h4><ul><li><p><strong>用户模式（user model）</strong>：非特权模式</p></li><li><p><strong>系统&#x2F;控制&#x2F;内核模式（kernel model）</strong>：特权模式</p></li><li><p>操作系统内核的典型功能：</p><table><thead><tr><th>功能</th><th>具体</th></tr></thead><tbody><tr><td>进程管理</td><td>①进程的创建和终止②进程的调度和分派③进程切换④进程同步和进程间通信的支持⑤管理进程控制块</td></tr><tr><td>内存管理</td><td>①为进程分配空间②交换③页和段管理</td></tr><tr><td>I&#x2F;O管理</td><td>①缓冲器管理②为进程分配I&#x2F;O通道和设备</td></tr><tr><td>支持功能</td><td>①中断处理②记账③监视</td></tr></tbody></table></li></ul><h4 id="3-4-2-进程创建"><a href="#3-4-2-进程创建" class="headerlink" title="3.4.2 进程创建"></a>3.4.2 进程创建</h4><ul><li>创建进程的步骤：<ol><li>分配一个唯一的进程标识符</li><li>分配空间（包括进程映像中所有元素）</li><li>初始化PCB</li><li>设置正确的链接（放置就绪或就绪&#x2F;挂起链表中）</li><li>创建或扩充其他数据结构</li></ol></li></ul><h4 id="3-4-3-进程切换"><a href="#3-4-3-进程切换" class="headerlink" title="3.4.3 进程切换"></a>3.4.3 进程切换</h4><ul><li><p>进程执行的中断机制：</p><table><thead><tr><th>机制</th><th>原因</th><th>用途</th></tr></thead><tbody><tr><td>中断</td><td>来自当前执行指令的外部</td><td>对异步外部事件的反应</td></tr><tr><td>陷阱</td><td>与当前执行指令相关</td><td>处理一个错误或一个异常条件</td></tr><tr><td>系统调用</td><td>显式请求</td><td>调用操作系统函数</td></tr></tbody></table></li><li><p>中断：</p><ul><li>时钟中断：当前运行进程的执行时间超过最大允许切换时间段（时间片time slice）<ul><li>进程切换到就绪态，调入另一进程</li></ul></li><li>I&#x2F;O中断：是否发生I&#x2F;O活动<ul><li>若I&#x2F;O活动是一个或多个进程正在等待的事件，操作系统把所有阻塞态转换为就绪态</li></ul></li><li>内存失效：处理器遇到一个引用不在内存中的字的虚存地址，操作系统需要从外存把包含这一引用的内存块调入内存<ul><li>内存失效的进程进入阻塞态；操作系统切换进程，恢复另一进程的执行。等期望的块调入后，该进程置为就绪态</li></ul></li></ul></li><li><p>陷阱（trap）：操作系统确定错误或异常条件是否致命</p><ul><li>致命时，当前正运行进程置为退出态，并切换进程</li></ul></li><li><p>系统调用（supervisor call）：系统调用时会将用户进程置为阻塞态</p></li><li><p>中断发生后并不一定进行进程切换，只是保存处理器状态信息，在控制权返回给该程序时恢复这些信息。</p></li><li><p>进程状态的变化：</p><ul><li>模式切换可在不改变运行态进程的状态下发生</li><li>进程转换发生时，环境会发生实质性变化：<ol><li>保存处理器上下文</li><li>更新当前处于运行态进程的PCB（包括状态转换、退出原因）</li><li>把该进程的PCB移到相应的队列</li><li>选择另一个进程执行</li><li>更新所选进程的PCB</li><li>更新内存管理数据结构</li><li>载入PC和其他寄存器先前的值</li></ol></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统_Chapter2</title>
    <link href="/2022/09/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Chapter2/"/>
    <url>/2022/09/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Chapter2/</url>
    
    <content type="html"><![CDATA[<h2 id="第2章-操作系统概述"><a href="#第2章-操作系统概述" class="headerlink" title="第2章 操作系统概述"></a>第2章 操作系统概述</h2><h3 id="2-1-操作系统的目标和功能"><a href="#2-1-操作系统的目标和功能" class="headerlink" title="2.1 操作系统的目标和功能"></a>2.1 操作系统的目标和功能</h3><ul><li>操作系统是控制应用程序执行的程序，是应用程序和计算机硬件间的接口</li><li>三个目标：<ul><li>方便：使计算机更易于使用（人机接口）</li><li>有效：以更有效的方式使用计算机系统资源（资源管理器）</li><li>扩展能力：在不妨碍服务的前提下，有效地开发、测试和引入新的系统功能（操作系统）</li></ul></li></ul><h4 id="2-1-1-作为用户-x2F-计算机接口的操作系统"><a href="#2-1-1-作为用户-x2F-计算机接口的操作系统" class="headerlink" title="2.1.1 作为用户&#x2F;计算机接口的操作系统"></a>2.1.1 作为用户&#x2F;计算机接口的操作系统</h4><ul><li>操作系统通常提供以下几个方面的服务：<ul><li><u>程序开发</u>：提供帮助程序员开发的工具和服务（编辑器和调试器）</li><li><u>程序运行</u>：为用户处理运行程序时的资源调度问题</li><li><u>I&#x2F;O设备访问</u>：提供操作I&#x2F;O设备的统一接口</li><li><u>文件访问控制</u>：可提供保护机制</li><li><u>系统访问</u>：提供对资源和数据的保护，以避免未授权用户的访问，同时解决资源竞争时的冲突问题</li><li><u>错误检测和响应</u>：提供响应以清除错误条件</li></ul></li></ul><h4 id="2-1-2-作为资源管理器的操作系统"><a href="#2-1-2-作为资源管理器的操作系统" class="headerlink" title="2.1.2 作为资源管理器的操作系统"></a>2.1.2 作为资源管理器的操作系统</h4><ul><li>操作系统作为控制机制的两方面不同：<ul><li>与普通计算机软件的作用相同，是由处理器执行的一段或一组程序</li><li>经常会释放控制，让其余就绪进程得到CPU以执行，而且必须依赖处理器恢复控制</li></ul></li><li>操作系统一部分在内存中，包括<strong>内核程序（kernel&#x2F;nucleus</strong>）（包含OS最常用功能，是核心）和当前正在使用的其他程序</li><li>OS决定何时使用I&#x2F;O设备、控制文件的访问和使用，并且决定在运行一个特定的用户程序时，可以分配多少处理器时间</li></ul><h4 id="2-1-3-操作系统的易扩展性"><a href="#2-1-3-操作系统的易扩展性" class="headerlink" title="2.1.3 操作系统的易扩展性"></a>2.1.3 操作系统的易扩展性</h4><ul><li>重要的操作系统要不断发展，原因如下：<ul><li>硬件升级和新型硬件的出现</li><li>新的服务</li><li>纠正错误</li></ul></li></ul><h3 id="2-2-操作系统的发展史"><a href="#2-2-操作系统的发展史" class="headerlink" title="2.2 操作系统的发展史"></a>2.2 操作系统的发展史</h3><h4 id="2-2-1-串行处理"><a href="#2-2-1-串行处理" class="headerlink" title="2.2.1 串行处理"></a>2.2.1 串行处理</h4><ul><li>程序员直接和计算机硬件打交道，没有操作系统</li><li>两个主要问题：<ul><li>调度：大多数装置使用硬拷贝登记表来预订机器时间，有时预订时间大于工作所需时间造成计算机闲置；有时出现问题来不及解决时间就到了</li><li>准备时间：称为作业的单个程序，在运行前的准备工作若发生了错误，用户只能从头开始，因此花费大量时间</li></ul></li></ul><h4 id="2-2-2-简单批处理系统"><a href="#2-2-2-简单批处理系统" class="headerlink" title="2.2.2 简单批处理系统"></a>2.2.2 简单批处理系统</h4><ul><li>使用一个<strong>监控程序（monitor）</strong>的软件，操作员把作业按顺序组织成批，放在输入设备上，供监控程序使用，每完成一个程序返回到监控程序，加载下一个程序</li><li>两个角度：<ul><li>监控程序角度：控制事件的顺序。大部分监控程序总是处于内存中并且可以执行，称为<strong>常驻监控程序（resident monitor）</strong>，其他部分包括一些实用程序和公用函数</li><li>处理器角度：“控制权交给作业”表示处理器当前取的和执行的都是用户程序中的指令；“控制权返回给监控程序”表示处理器当前从监控程序中取指令并执行（CPU在monitor和用户作业间的使用权限转换来看简单批处理）</li></ul></li><li>监控程序完成调度功能也改善了作业的准备时间，每个作业中的指令均以一种<strong>作业控制语言（Job Control Language，JCL）</strong>的基本形式给出</li><li>其他硬件功能：<ul><li>内存保护：用户程序运行时不能改变包含监控程序的内存区域</li><li>定时器：防止一个作业独占系统</li><li>特权指令：只能由监控程序执行（I&#x2F;O指令等）</li><li>中断</li></ul></li><li>内存保护和特权指令引出了运行模式的概念：<ul><li><strong>用户模式（user mode）</strong>：用户程序执行，部分内存区域受保护，特权指令不允许执行</li><li><strong>内核模式（kernel mode）</strong>：监控程序执行，可以执行特权指令，可以访问受保护内存</li></ul></li></ul><h4 id="2-2-3-多道批处理系统"><a href="#2-2-3-多道批处理系统" class="headerlink" title="2.2.3 多道批处理系统"></a>2.2.3 多道批处理系统</h4><ul><li>简单批处理的作业经常I&#x2F;O命令，一旦I&#x2F;O中断，若内存中只有一个用户作业，则CPU要等待</li><li><strong>多道程序设计（multiprogramming）&#x2F;多任务处理（multitasking）</strong>：内存空间容得下操作系统和多个用户程序，当一个作业需要等待I&#x2F;O时，处理器切换到另一个可能并不在等待I&#x2F;O的作业</li><li>需要注意的问题：<ul><li>内存管理：待运行的作业需要保存在内存中</li><li>调度：处理器决定运行哪个作业</li><li>资源竞争</li></ul></li></ul><h4 id="2-2-4-分时系统"><a href="#2-2-4-分时系统" class="headerlink" title="2.2.4 分时系统"></a>2.2.4 分时系统</h4><ul><li><p>多个用户分享处理器时间，该技术称为<strong>分时（time sharing）</strong></p></li><li><p>在分时系统中，多个用户可以通过终端同时访问系统，由操作系统控制每个用户程序在很短的时间内交替执行</p></li><li><p>多道批处理与分时的比较</p><table><thead><tr><th></th><th>多道批处理</th><th>分时</th></tr></thead><tbody><tr><td>主要目标</td><td>充分利用处理器</td><td>减小响应时间</td></tr><tr><td>操作系统指令源</td><td>作业控制语言命令（JCL）<br>作业提供的命令</td><td>终端键入的命令</td></tr></tbody></table></li><li><p><strong>时间片（time slicing）</strong>：在固定的时间间隔内，当前用户被抢占，另一个用户被载入的技术</p></li><li><p>也存在内存管理、访问控制、资源竞争的问题</p></li></ul><h3 id="2-3-主要成就"><a href="#2-3-主要成就" class="headerlink" title="2.3 主要成就"></a>2.3 主要成就</h3><ul><li>4个重要理论进展：<ul><li>进程</li><li>内存管理</li><li>信息保护和安全</li><li>调度和资源管理</li></ul></li></ul><h4 id="2-3-1-进程"><a href="#2-3-1-进程" class="headerlink" title="2.3.1 进程"></a>2.3.1 进程</h4><ul><li>程序设计出错的主要原因：<ul><li><u>不正确的同步</u>：例如不正确的信号机制</li><li><u>失败的互斥</u>：多个用户或程序试图同时访问一个共享资源时，互斥机制出错</li><li><u>不确定的程序操作</u>：程序调度顺序可能会影响某个特定程序的输出结果</li><li><u>死锁</u>：很可能有两个或多个程序相互挂起等待</li></ul></li><li>解决以上问题，需要一种系统级方法监控处理器中不同程序的执行，进程为此提供基础</li><li>进程的组成三部分：<ul><li>一段可执行的程序</li><li>程序所需要的相关数据（变量、工作空间、缓冲区等）</li><li>程序的执行上下文</li></ul></li><li><strong>执行上下文（execution context）</strong>&#x2F;<strong>进程状态（process state）</strong>：操作系统用来管理和控制进程所需的内部数据</li><li><strong>线程（thread）</strong>：一个分配了资源的进程可分解为多个并发的线程，这些线程相互协作执行，完成进程的工作</li></ul><h4 id="2-3-2-内存管理"><a href="#2-3-2-内存管理" class="headerlink" title="2.3.2 内存管理"></a>2.3.2 内存管理</h4><ul><li>5项存储器管理职责：<ul><li>进程隔离</li><li>自动分配和管理</li><li>支持模块化程序设计</li><li>保护和访问控制</li><li>长期存储</li></ul></li><li>使用<strong>虚存</strong>和<strong>文件系统</strong>机制满足上述要求<ul><li>文件系统：在一个有名称的对象（即文件file）中保存信息，实现长期存储</li><li>虚存（virtual memory）：允许程序以逻辑方式访问存储器，不考虑物理内存上的可用空间数量。</li><li>程序使用虚地址访问，虚地址将映射成真实的内存地址，如果访问的虚地址不在实际内存中，实际内存中的一部分内容将换到外存中，然后换入所需要的数据块。</li></ul></li></ul><h4 id="2-3-3-信息保护和安全"><a href="#2-3-3-信息保护和安全" class="headerlink" title="2.3.3 信息保护和安全"></a>2.3.3 信息保护和安全</h4><ul><li>四类安全和保护问题：<ul><li>可用性：保护系统不被中断</li><li>保密性：保护用户不能读取未授权访问的数据</li><li>数据完整性：保护数据不被未授权修改</li><li>认证：涉及用户身份的正确认证和消息或数据的合法性</li></ul></li></ul><h4 id="2-3-4-调度和资源管理"><a href="#2-3-4-调度和资源管理" class="headerlink" title="2.3.4 调度和资源管理"></a>2.3.4 调度和资源管理</h4><ul><li>考虑3个因素：<ul><li>公平性</li><li>有差别的响应性</li><li>有效性（最大吞吐量、最小响应时间、尽可能多用户）</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统_Chapter1</title>
    <link href="/2022/09/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Chapter1/"/>
    <url>/2022/09/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Chapter1/</url>
    
    <content type="html"><![CDATA[<h2 id="第1章-计算机系统概述"><a href="#第1章-计算机系统概述" class="headerlink" title="第1章 计算机系统概述"></a>第1章 计算机系统概述</h2><h3 id="1-1-基本构成"><a href="#1-1-基本构成" class="headerlink" title="1.1 基本构成"></a>1.1 基本构成</h3><ul><li>4个主要的结构化部件：<ul><li>处理器（Processor）</li><li>内存（Main memory）</li><li>输入&#x2F;输出模块（I&#x2F;O modules）</li><li>系统总线（System bus)</li></ul></li><li>CPU内部<ul><li>PC（Program Counter，程序计数器）：保存下一次要取的指令地址</li><li>IR（Instruction Register，指令寄存器）：保存取到的指令</li><li>AC（Accumulator，累加器）：保存计算产生的中间结果</li><li>MAR（Memory Address Register，存储器地址寄存器）：确定下一次读&#x2F;写的存储器地址</li><li>MBR（Memory Buffer Register，存储缓冲寄存器）：存放写入&#x2F;读出存储器的数据</li><li>IO&#x2F;AR（I&#x2F;O Address Register，输入&#x2F;输出地址寄存器）：确定一个特定I&#x2F;O设备</li><li>IO&#x2F;BR（I&#x2F;O Buffer Register，输入&#x2F;输出缓冲寄存器）：用于I&#x2F;O模块和处理器交换数据</li></ul></li></ul><h3 id="1-2-指令的执行"><a href="#1-2-指令的执行" class="headerlink" title="1.2 指令的执行"></a>1.2 指令的执行</h3><ul><li>处理器执行的程序有一组保存在存储器中的指令组成。</li><li>单个指令所需要的处理称为一个指令周期：取指阶段和执行阶段</li><li>所有指令和数据长度均为16位，使用16位的单元或字长组织存储器</li><li>指令格式有4位是操作码，最多有2的4次方（16）种不同操作码，定义了处理器执行的操作，后12位是访问的数据地址</li></ul><h3 id="1-3-中断"><a href="#1-3-中断" class="headerlink" title="1.3 中断"></a>1.3 中断</h3><ul><li>中断的分类：<ul><li>程序中断：在某些条件下由执行的结果产生（算术溢出、除数为0）</li><li>时钟中断：处理器内部的计时器产生</li><li>I&#x2F;O中断：由I&#x2F;O控制器产生，通知正常完成或错误条件</li><li>硬件失效中断：掉电或存储器奇偶校验错等故障发生</li></ul></li></ul><h4 id="1-3-1-中断和指令周期"><a href="#1-3-1-中断和指令周期" class="headerlink" title="1.3.1 中断和指令周期"></a>1.3.1 中断和指令周期</h4><ul><li>中断处理程序（interrupt handler）：外部设备的I&#x2F;O模块给处理器发送中断请求信号，处理器暂停当前程序的处理，转去处理服务于特定I&#x2F;O设备的程序。</li><li>为适应中断产生，指令周期中增加一个中断阶段</li><li>中断处理必须执行额外的指令以确定中断的性质和采用何种操作，与简单等待I&#x2F;O操作完成花费更多时间相比，中断能使I&#x2F;O操作与处理器并发执行，提高处理器效率。</li></ul><h4 id="1-3-2-中断处理"><a href="#1-3-2-中断处理" class="headerlink" title="1.3.2 中断处理"></a>1.3.2 中断处理</h4><ul><li>当I&#x2F;O设备完成一次I&#x2F;O操作时，发生下列<strong>硬件事件</strong>：<ul><li>设备给处理器发送中断信号</li><li>处理器结束当前指令的执行</li><li>处理器确认存在未响应中断，并给提交中断的设备发送确认信号</li><li>处理器保存从中断点恢复当前程序所需要的信息（把程序状态字PSW和PC压入控制栈）</li><li>根据中断，处理器加载新PC值</li></ul></li><li>新PC值意味处理器进行下一指令周期，控制权被转交到中断处理程序，执行以下<strong>软件操作</strong>：<ul><li>保存剩余的处理状态信息（PC、PSW、寄存器的内容保存到系统栈）</li><li>处理中断</li><li>恢复处理状态信息（被保存的寄存器值从栈中释放并恢复到寄存器中）</li><li>恢复旧PSW和PC</li></ul></li></ul><h4 id="1-3-3-多个中断"><a href="#1-3-3-多个中断" class="headerlink" title="1.3.3 多个中断"></a>1.3.3 多个中断</h4><ul><li>处理多个中断的两种方法：<ul><li>正在处理一个中断时，禁止再发生中断（对其他中断信号不响应，保持挂起）</li><li>定义中断优先级，允许高优先级打断低优先级中断的运行</li></ul></li><li>中断服务例程：Interrupt Service Routine，ISR</li></ul><h3 id="1-4-存储器的层次结构"><a href="#1-4-存储器的层次结构" class="headerlink" title="1.4 存储器的层次结构"></a>1.4 存储器的层次结构</h3><ul><li><p>存储器三个重要特性：价格、容量、访问时间</p></li><li><p><strong>存储器层次结构（memory hierarchy）</strong>：从上往下看，</p></li><li><table><thead><tr><th>层次</th><th>具体存储器</th></tr></thead><tbody><tr><td>板上存储器</td><td>寄存器—&gt;高速缓存—&gt;内存</td></tr><tr><td>板外存储器</td><td>磁盘、CD-ROM、CD-RW、DVD-RW、DVD-RAM、Blu-Ray</td></tr><tr><td>离线存储器</td><td>磁带</td></tr></tbody></table><p>从上往下：</p><ul><li>每“位”的价格递减</li><li>容量递增</li><li>存取时间递增</li><li>处理器访问存储器的频率递减</li></ul></li><li><p><strong>命中率（hit ratio）</strong>：对较快存储器（如高速缓存）的访问次数与对所有存储器的访问次数的比值。</p></li><li><p>板上存储器通常是易失性，采用半导体技术，数据表现形式为byte或word</p></li><li><p>非易失性外部存储器又称，二级存储器（secondary memory）或辅助存储器（auxiliary memory），数据存储形式为file或record</p></li></ul><h3 id="1-5-高速缓存"><a href="#1-5-高速缓存" class="headerlink" title="1.5 高速缓存"></a>1.5 高速缓存</h3><h4 id="1-5-1-动机"><a href="#1-5-1-动机" class="headerlink" title="1.5.1 动机"></a>1.5.1 动机</h4><ul><li>处理器速度提高快于存储器访问速度的提高</li><li>解决方法：在处理器和内存之间提供一个容量小且速度快的存储器，称为高速缓存（cache）</li></ul><h4 id="1-5-2-高速缓存原理"><a href="#1-5-2-高速缓存原理" class="headerlink" title="1.5.2 高速缓存原理"></a>1.5.2 高速缓存原理</h4><ul><li>高速缓存包含一部分内存数据的副本，当处理器读取存储器时：<ul><li>检查改字是否在高速缓存中</li><li>如果在，传递给处理器</li><li>如果不在，由固定数目的字节组成的一块内存数据读入高速缓存，再传递给处理器</li></ul></li><li>根据访问<strong>局部性原理（principle of locality）</strong>,位于被访问字附件的数据在近期被访问到的概率较大</li><li>内存的系统结构：<ul><li>由2^n个可寻址的字组成，每个字有唯一的n位地址</li><li>划分成固定的块（block），每块包含K个字，即共有M&#x3D;2^n&#x2F;K个块</li></ul></li><li>高速缓存的系统结构：<ul><li>有C个存储槽（slots&#x2F;lines），每个槽有K个字，槽的数量远小于存储器中块的数量（C&lt;&lt;M)</li><li>由于一个槽不能唯一或永久对应于一个块，每个槽中有个标签，标识当前存储的是哪个块</li></ul></li></ul><h4 id="1-5-3-高速缓存设计"><a href="#1-5-3-高速缓存设计" class="headerlink" title="1.5.3 高速缓存设计"></a>1.5.3 高速缓存设计</h4><ul><li><strong>高速缓存大小（cache size）</strong>：适当小的高速缓存会对性能产生明显的影响</li><li><strong>块大小（block size）</strong>：即高速缓存与内存之间的数据交换单位，当块大小从很小增长到很大时，由于局部性原理，命中率首先会增加；当块更大时，新近取到的数据被用到的可能性开始小于被疑出缓存的数据再次被用到的可能性，命中率开始降低。</li><li><strong>映射函数（mapping function）</strong>：确定这个块将占据哪个高速缓存单元</li><li><strong>置换算法（replacement algorithm）</strong>：选择置换那些在不久的将来被访问的可能性最小的块</li><li><strong>写策略（write policy）</strong>：规定何时发生存储器写操作<ul><li>每当块被更新后就发生写操作</li><li>只有当被置换时才发生写操作（会使内存处于过时状态）</li></ul></li></ul><h3 id="1-6-直接内存存取"><a href="#1-6-直接内存存取" class="headerlink" title="1.6 直接内存存取"></a>1.6 直接内存存取</h3><ul><li>可编程I&#x2F;O（programmed I&#x2F;O）<ul><li>处理器正在执行程序遇到一个与I&#x2F;O相关的指令时，通过给相应的I&#x2F;O模块发命令执行这个指令</li><li>不会中断处理器，处理器轮巡检查I&#x2F;O操作是否完成</li></ul></li><li>中断驱动I&#x2F;O（interrupt-driven I&#x2F;O）<ul><li>处理器给I&#x2F;O模块发送I&#x2F;O命令，然后处理器继续其他工作</li><li>当I&#x2F;O模块准备好与处理器交换数据时，打断处理器的执行并请求服务</li><li>处理器仍然主动干预在存储器和I&#x2F;O模块之间的数据传送</li></ul></li><li>直接内存存取（Direct Memory Access，DMA）<ul><li>DMA功能由系统总线中的一个独立模块完成，也可以并入一个I&#x2F;O模块中</li><li>处理器读或写一块数据时，给DMA模块产生一条命令，之后处理器继续其他工作</li><li>DMA模块直接与存储器交互，传送数据块，完成后向处理器发送中断信号。</li><li>只有在开始传送和结束时处理才会参与（两次中断）</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/09/08/hello-world/"/>
    <url>/2022/09/08/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
