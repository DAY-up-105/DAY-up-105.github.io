<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>语音伪造及检测技术研究综述</title>
    <link href="/2022/10/10/%E8%AF%AD%E9%9F%B3%E4%BC%AA%E9%80%A0%E5%8F%8A%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6%E7%BB%BC%E8%BF%B0/"/>
    <url>/2022/10/10/%E8%AF%AD%E9%9F%B3%E4%BC%AA%E9%80%A0%E5%8F%8A%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6%E7%BB%BC%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h3><ul><li>语音伪造技术的恶意攻击对象分为<strong>人类听觉系统（Human Audio System，HAS）</strong>和机器听觉系统两大类</li><li>针对<strong>说话人验证系统（Automatic Speaker Verification，ASV）</strong>的恶意攻击，将非法获取目标用户的访问权限</li></ul><h3 id="2-语音伪造技术"><a href="#2-语音伪造技术" class="headerlink" title="2 语音伪造技术"></a>2 语音伪造技术</h3><ul><li>语音伪造的目的是生成目标说话人的声音，以欺骗人类听觉系统（HAS）或自动说话人验证系统（ASV）</li><li>目前的语音伪造技术主要包括：<ul><li><strong>语音模仿（Impersonation）</strong>：通过人类模拟产生目标说话人风格的语音，属于非自动化的语音伪造手段</li><li><strong>语音合成（Text to Speech，TTS）</strong>：根据给定的语言内容合成目标说话人风格的语音，实现文本到声音的映射</li><li><strong>语音转换（Voice Conversion，VC）</strong>：将源说话人的语音转换为目标说话人风格的语音，实现声音到声音的映射</li><li><strong>重放攻击（Replay Attack，RA）</strong>：对目标说话人的语音通过设备录制后进行编辑和回放以产生高度逼真的目标说话人语音（常用于攻击ASV系统）</li><li><strong>对抗攻击（Adversarial Attack）</strong>：通过对抗样本技术，在语音信号上添加微量扰动实现对ASV系统的攻击</li></ul></li><li><img src="/img/语音伪造及检测技术研究综述/1.png" alt=""></li></ul><h4 id="2-1-语音合成"><a href="#2-1-语音合成" class="headerlink" title="2.1 语音合成"></a>2.1 语音合成</h4><ul><li><p>典型的语音合成系统如图2所示</p><p><img src="/img/语音伪造及检测技术研究综述/2.png" alt=""></p><p>包括：</p><ul><li><strong>前端文本分析</strong>：将输入文本通过规范化、分词、词性标注等步骤生成对应的音素序列、时长预测等信息</li><li><strong>后端语音波形生成</strong>：根据文本分析生成的语言规范合成目标说话人的语音波形</li></ul></li><li><p>传统语音合成主要包括<strong>波形拼接法</strong>和<strong>参数生成法</strong></p><ol><li>波形拼接法<ul><li>将自然语音数据中的语音单元按照一定的规则拼接，合成与目标说话人高度相似且自然的语音，包括语料库收集、声学单元选取、拼接伪造等步骤</li><li>代表性工作：基音同步叠加的PSOLA技术、利用隐马尔可夫模型（Hidden Markov Model，HMM）限制目标单元韵律参数的单元选择系统</li><li>适用于某些特定领域（天气预报、报时等）</li><li>使用真实语音片段，最大限度保留语音音质，但是需要大量目标说话人语料，对于不同领域的文本合成稳定性不强，容易被人或机器识别</li></ul></li><li>参数生成法<ul><li>通过声学模型预测声学参数，将声学参数通过声码器合成目标说话人语音</li><li>代表性工作：基于HMM的统计参数合成方法、基于DNN的参数合成方法</li><li>输出语音稳定流畅，但受限于参数合成器的缺陷以及统计建模的损失</li></ul></li></ol></li><li><p>采用深度学习方法的技术主要包括<strong>管道式（Pipeline）语音合成</strong>和<strong>端到端式语音合成</strong>两类</p><ol><li>管道式语音合成<ul><li>三个模块<ul><li>文本分析：根据输入文本进行韵律预测和每个音素的时长预测</li><li>声学模型：建立文本特征和声学特征之间的联系，根据文本分析的输出经由DNN映射到声学特征</li><li>声码器：实现声学参数到语音波形的转换</li></ul></li><li>限制：多个模块之间会产生误差积累，需要高昂成本的文本标注以及文本特征和声学特征的强制对齐</li></ul></li><li>端到端式语音合成<ul><li>实现了直接输入文本或注音字符，输出音频波形</li><li>自回归语音合成<ul><li>基于序列到序列的生成模型，语音合成效果优，但速度较慢</li><li>2016Google提出的WaveNet语音合成算法<ul><li>通过扩张因果卷积网络根据当前时刻采样点生成下一采样点</li><li>直接对原始语音数据进行建模，避免了声码器对语音进行参数化时导致的音质损失</li><li>无法实现输入文本或标注音符到输出语音的直接转换</li></ul></li><li>2017年第一个端到端语音合成系统Tacotron<ul><li>引入了注意力机制，输入文本或注音字符，输出线性语谱图，再通过Griffin-Lim算法生成语音波形</li><li>所有特征模型可学习调优，便于添加语种、音色、情感等限制条件</li><li>但模型复杂，纠错能力和人为干预能力差，音质不如WaveNet</li></ul></li><li>2018年Tacotron2简化了前端模型结构<ul><li>基于文本输入生成梅尔语谱图</li><li>通过改进的WaveNet声码器合成语音波形</li></ul></li><li>2021年提出Wave-Tacotron端到端语音合成系统<ul><li>通过在自回归解码器中添加规范化流来扩展Tacotron系统</li><li>不生成中间特征，无需声码器实现文本到波形的端到端语音合成</li></ul></li></ul></li><li>非自回归语音合成<ul><li>基于全并行网络结构，通过一次前馈计算生成整句语音，极大提升速度，可控性强且语音合成质量接近自回归模型效果</li><li>2019年——基于源滤波的实时参数语音合成模型<ul><li>基于频谱距离和相位距离的训练准则</li><li>对给定的输入声学特征，通过源模块、基音F0和谐波加噪模型生成正弦激励信号</li><li>然后通过级联扩张卷积和长短期记忆网络（LSTM）将激励信号和频谱特征转换成语音波形</li></ul></li><li>2019年——基于Transformer的语音合成系统FastSpeech<ul><li>从基于编码器-解码器的教室模型中提取注意力对齐来预测音素持续时间</li><li>通过长度调节扩展源音素序列以匹配目标音素序列的长度，并生成梅尔谱图</li><li>语音质量与自回归模型相当，极大提升了语音生成速度</li></ul></li><li>2020年——FastSpeech2<ul><li>解决了FastSpeech中师生蒸馏复杂且耗时的问题</li><li>引入更多语音变化信息，进一步提升语音音质和生成速度</li></ul></li><li>2021年——Parallel Tacotron<ul><li>基于变分自编码器（VAE）的残差编码器扩展了Tacotron系统</li></ul></li><li>2021年——基于FastSpeech的全并行语音合成系统FastPitch<ul><li>在语音生成过程中改变基音轮廓预测以匹配话语语义</li></ul></li><li>2021年——可快速生成高质量语音的多频带MelGAN模型<ul><li>将频谱图作为生成器的输入，输出子带表示，将其合并成全波段信号表示后输入鉴别器</li><li>同时使用多分辨率STFT损失替换原始的特征匹配损失</li></ul></li></ul></li></ul></li></ol></li></ul><h3 id="3-伪造语音检测技术"><a href="#3-伪造语音检测技术" class="headerlink" title="3 伪造语音检测技术"></a>3 伪造语音检测技术</h3><h4 id="3-1-伪造语音检测系统通用结构"><a href="#3-1-伪造语音检测系统通用结构" class="headerlink" title="3.1 伪造语音检测系统通用结构"></a>3.1 伪造语音检测系统通用结构</h4><ul><li>典型的伪造语音检测系统一般由前后端两部分组成<ul><li>前端：分析语音信号<strong>提取具有区分性的特征</strong></li><li>后端：<strong>分类判断</strong>语音是真实语音还是伪造语音</li></ul></li><li>基于深度学习的系统前端提取输入神经网络的语音特征，后端通过神经网络学习特征的高级表示，进行分类判决</li><li><img src="/img/语音伪造及检测技术研究综述/3.png" alt=""></li></ul><h4 id="3-2-攻击场景和评价指标"><a href="#3-2-攻击场景和评价指标" class="headerlink" title="3.2 攻击场景和评价指标"></a>3.2 攻击场景和评价指标</h4><h5 id="3-2-1-攻击场景"><a href="#3-2-1-攻击场景" class="headerlink" title="3.2.1 攻击场景"></a>3.2.1 攻击场景</h5><ul><li><p>身份认证应用中常用的ASV系统结构及其主要可能存在的攻击节点：</p><p><img src="/img/语音伪造及检测技术研究综述/4.png" alt=""></p><ul><li>节点1和2为直接攻击节点，发生在语音声纹特征提取之前</li><li>节点3-8为间接攻击节点，攻击者可以介入ASV内部处理流程中的各个操作环节</li></ul></li><li><p>根据伪造语音输入目标ASV系统的途径，可将伪造语音攻击分为<strong>物理访问（Physical Access，PA）攻击</strong>和<strong>逻辑访问（Logical Access，LA）攻击</strong></p><ul><li>PA中语音样本以空气传播的方式通过麦克风捕获后输入目标ASV系统</li><li>LA中语音样本直接输入目标ASV系统</li><li>伪造语音检测常用数据集可分为LA和PA两类<ul><li>LA场景的伪造语音类型包括转换语音、合成语音等</li><li>PA场景的伪造语音包括重放语音</li></ul></li></ul></li></ul><h5 id="3-2-2-评价指标"><a href="#3-2-2-评价指标" class="headerlink" title="3.2.2 评价指标"></a>3.2.2 评价指标</h5><ul><li><p>伪造语音检测算法的常用性能指标包括<strong>等错误率（Equal Error Rate，EER）</strong>和<strong>串联检测代价函数（tandem Detection Cost Function，t-DCF）</strong></p><ol><li><p>等错误率（EER）</p><ul><li><p>等错误率（EER）是<strong>错误接受率（False Accept Rate，FAR）</strong>和<strong>错误拒绝率（Fasle Rejection Rate，FRR）</strong>相等时的错误率</p><ul><li>错误接受：将伪造语音错误分类成真实语音</li><li>错误拒绝：将真实语音错误分类为伪造语音</li></ul></li><li><p>给定检测系统的检测分数和阈值θ，错误接受率和错误拒绝率可分别按式（1）和式（2）计算：</p><script type="math/tex; mode=display">P_{fa}(θ)=\frac{得分>阈值θ的伪造语音个数}{伪造语音总数}\quad(1)\\P_{miss}(θ)=\frac{得分≤阈值θ的真实语音个数}{真实语音总数}\quad(2)</script></li><li><p>式（1）和式（2）分别是θ的单调递减函数和单调递增函数</p></li><li><p>阈值为θ时的等错误率EER对应于式（1）和式（2）相等时的值，即</p><script type="math/tex; mode=display">EER=P_{fa}(θ)=P_{miss}(θ)</script></li><li><p><strong>等错误率越小代表伪造语音检测系统的效果越好</strong>，但该指标未考虑伪造语音检测系统对ASV系统可靠性的影响</p></li></ul></li><li><p>串联检测代价函数（t-DCF）</p><ul><li><p>并非独立评估，而是反映了实际情况下伪造语音和伪造语音检测系统对ASV系统性能共同产生的影响</p></li><li><p>实际中ASV系统可能遇到合法用户、临时冒充的非法用户以及试图恶意操作ASV决策的攻击者，该指标综合考虑了不同情况下的误判代价</p></li><li><p>简要计算过程如下</p><script type="math/tex; mode=display">min\,t-DCF=\underset{\theta}{min} \{ \beta{P_{miss}(\theta)+P_{fa}(\theta)} \}</script><ul><li>系数β取决于实际中的伪造攻击优先级、误判成本以及ASV系统的检测性能（FA和FR等）</li></ul></li><li><p><strong>t-DCF越小说明检测系统的泛化性能越好</strong></p></li></ul></li></ol></li></ul><h4 id="3-3-针对语音合成-转换的伪造语音检测技术"><a href="#3-3-针对语音合成-转换的伪造语音检测技术" class="headerlink" title="3.3 针对语音合成/转换的伪造语音检测技术"></a>3.3 针对语音合成/转换的伪造语音检测技术</h4><ul><li>早期语音合成检测方案主要考虑语音信号、声纹特征和频谱分布等生物信息的差异特征</li><li>部分研究集中于声码器和自然语音之间的声学差异</li><li>传统语音合成方法难以建立可靠的韵律模型，部分工作使用基频信息进行检测：<ul><li>统计参数合成方法生成语音的基频F0通常过度平滑</li><li>波形拼接方法生成语音的单元连接点处F0跳跃</li></ul></li><li>基于DNN的合成语音检测系统的研究主要集中在<strong>特征提取方法</strong>，<strong>特征表示学习网络结构设计</strong>和<strong>损失函数设计</strong>三个方面。</li></ul><h5 id="3-3-1-前端特征提取"><a href="#3-3-1-前端特征提取" class="headerlink" title="3.3.1 前端特征提取"></a>3.3.1 前端特征提取</h5><ul><li>前端工作主要研究如何提取伪造语音中可区分于真实语音的特征以输入后端进行判决（如伪造语音通常缺少频谱和时间细节信息）</li><li>目前伪造语音检测的常用特征主要分为三大类：<ul><li>频谱特征（最广泛）</li><li>身份特征</li><li>原始波形</li><li><img src="/img/语音伪造及检测技术研究综述/5.png" alt=""></li></ul></li></ul><ol><li>短时功率谱特征<ul><li>描述了信号功率随频率的变化情况</li><li>常用的短时功率谱特征<ul><li>对数功率谱</li><li>基于滤波器的倒谱系数（Filter-Based Cepstral Coefficient，FBCC）：梅尔频率倒谱系数（MFCC）、矩形滤波倒谱系数（LFCC）</li><li>基于全极点语音建模参数的倒谱系数：线性预测倒谱系数（LPCC）</li></ul></li><li>由于<strong>伪造语音无法很好地模拟语音的时间特征</strong>，因此倒谱的高阶系数和一阶、二阶动态差分系数都有利于进行伪造语音检测</li><li><img src="/img/语音伪造及检测技术研究综述/6.png" alt=""></li></ul></li><li>短时幅度谱特征<ul><li>对数幅度谱（Log Magnitude Spectrum，LMS）：包含语音信号的细节信息，如共振峰、基音和元音的谐波结。</li><li>残差对数幅度谱（Residual Log Magnitude Spectrum，RLMS）：从线性预测编码（LPC）残差波形中提取，包含谐波等频谱细节信息</li><li>与LMS相比，RLMS消除了共振峰影响。</li></ul></li><li>短时相位特征<ul><li><strong>声码器重建波形时会忽略相位信息</strong>，因此短时相位特征是检测伪造语音的有效特征之一</li><li>由傅里叶变换得到的相位谱存在相位扭曲，需对其进行处理以得到稳定有效的相位特征</li><li>常用的相位特征：<ul><li>群延迟（Group Delay，GD）</li><li>改进的群延迟（Modified Group Delay，MGD）</li><li>基带相位差（Baseband Phase Difference，BPD）</li><li>瞬时频率导数（Instantaneous Frequency Derivative，IF）</li><li>相对相位偏移（Relative Phase Shift，RPS）</li></ul></li><li><img src="/img/语音伪造及检测技术研究综述/7.png" alt=""></li></ul></li><li>基于长时变换的特征<ul><li>耳蜗滤波器瞬时频率倒谱系数（CFCCIF）</li><li>基于长时常数Q变换的倒谱系数（CQCC）<ul><li>专门为伪造语音检测工作设计的特征，基于长时窗口恒定Q变换（CQT），对LA和PA场景下不同类别的攻击均有效</li><li><img src="/img/语音伪造及检测技术研究综述/8.png" alt=""></li></ul></li></ul></li><li>基于子带变换的特征<ul><li>伪造语音的干扰存在于语音的子带级别，只有<strong>在同频带中提取高分辨率特征</strong>才能可靠地提取这些干扰信息</li><li>子带变换相比于全频带变换<strong>更可靠地捕捉伪造语音中特定频段内的精细特征</strong></li><li>三种基于子带变换的特征：<ul><li>恒Q等子带变换（CQ-EST)</li><li>恒Q倍频程子带变换（CQ-OST）</li><li>离散傅里叶梅尔子带变换（DF-MST）</li></ul></li><li>通过静态系数、动态差分系数和加速度系数的特征组合可达到远超CQCC、MFCC特征的效果</li><li><img src="/img/语音伪造及检测技术研究综述/9.png" alt=""></li></ul></li></ol><ul><li>目前工作基本采用<strong>融合多个不同前端的子系统</strong>的方法，综合不同特征的优势以达到更好检测效果</li></ul><h5 id="3-3-2-后端分类模型"><a href="#3-3-2-后端分类模型" class="headerlink" title="3.3.2 后端分类模型"></a>3.3.2 后端分类模型</h5><ul><li>借助神经网络的特征学习能力，最新的检测系统后端<strong>对前端输入特征学习其高级特征表示后再进行分类</strong></li><li>目前大多数工作针对特定攻击或基于固定数据集，单个系统无法高效地检测多种不同的伪造攻击（TTS、VC和TTS-VC混合等）和训练集中不存在的未知攻击</li><li>实际中难以提前获知攻击类型，因此最新的研究重点普遍集中于<strong>提高检测的泛化性</strong>——能跨越不同伪造攻击类型并可抵抗不同通道环境噪声干扰的通用检测系统</li><li>目前，基于DNN的研究工作主要包括深度神经网络结构、损失函数和深度网络训练方法</li></ul><ol><li>深度神经网络结构<ul><li>后端网络一般采用基于卷积神经网络（CNN）的架构，如<strong>轻量卷积神经网络（LCNN）</strong>、<strong>残差网络（ResNet）</strong>、<strong>挤压-激励网络（SENet）</strong>等</li><li>ResNet<ul><li>为解决深层网络的<u>退化</u>和<u>梯度消失</u>问题（较低层难以在训练中接受有用的更新信息）提出</li><li>核心思想：使用跳过连接作为捷径，减少深层网络的训练参数，允许训练过程中参数更新更快地向较低层传播</li></ul></li><li>LCNN<ul><li>可在<u>减少计算成本和存储空间</u>的情况下<u>处理带有大量噪声标签的大规模数据</u></li><li>核心：每个卷积层后引入了<strong>最大特征图（Max Feature Map，MFM）激活函数</strong></li><li>相比ReLU，MFM激活后得到的特征图更紧密，同时可实现特征选择和特征降维</li></ul></li><li>SENet<ul><li>核心：通过挤压-激励操作显示<u>建模通道之间的相互依赖性</u></li><li>先对特征图进行挤压操作得到通道级全局特征，再对全局特征做激励以学习各通道间关系</li><li><strong>为不同通道分配不同影响权重</strong>，从而提高了模型专注于伪造检测最相关的通道信息能力</li></ul></li></ul></li><li>损失函数<ul><li>常用<strong>交叉熵损失（softmax损失）</strong>或<strong>AM-softmax损失</strong></li><li>主要针对现有检测系统对<u>未知数据泛化能力不佳</u>的问题进行损失设计</li><li>增强边缘余弦损失函数（LMCL）<ul><li>将softmax损失重整为余弦损失，迫使DNN学习可最大化类间方差并最小化类内方差的特征表示</li></ul></li><li>OC-softmax<ul><li>通过压缩真实语音的表示来区分真实与伪造语音</li></ul></li><li>基于核密度估计（KDE）的损失函数<ul><li>通过估计每个小批次内数据类的概率密度函数，计算每个小批次内所有训练类的KDE损失</li></ul></li><li>使用概率-相似度梯度（P2SGrad）的无超参数的均方误差损失函数<ul><li>通过总结比较常用的不同损失函数的性能，基于边缘的softmax对超参数设置敏感的问题提出</li></ul></li></ul></li><li>深度网络训练方法<ul><li>从此角度研究如何提高检测系统的泛化能力，如采用<strong>自监督学习</strong>、<strong>域自适应学习</strong>、<strong>对抗训练</strong>等</li><li>基于多任务自监督学习的伪造语音检测方案SSAD<ul><li>使用<u>基于时域卷积网络（TCN）的SSAD编码器</u>提取原始音频的深层表示，同时通过<u>最小化回归任务和二分类任务的损失帮助编码器获取更好的高级表示</u></li><li>SSAD提取高维特征后输入LCNN-big网络进行判别</li></ul></li><li>为解决数据集中信道不匹配的问题，提出了多任务学习和对抗训练两种网络<ul><li>多任务学习网络中增加了<u>信道分类器</u></li><li>对抗训练网络在前者基础上在信道分类器前添加<u>梯度反转层</u>，形成最大最小化的对抗训练，当训练稳定时，网络可学习到无关于信道影响的深度特征表示</li></ul></li><li>使用连续学习方法训练伪造语音检测系统DFWF<ul><li>可帮助减少对过去知识的遗忘</li><li>同时通过在真实语音中增加额外的正样本对齐（PSA）约束，保持真实语音特征表示分布的一致性</li></ul></li><li><img src="/img/语音伪造及检测技术研究综述/10.png" alt=""></li></ul></li></ol><h3 id="4-伪造语音检测竞赛"><a href="#4-伪造语音检测竞赛" class="headerlink" title="4 伪造语音检测竞赛"></a>4 伪造语音检测竞赛</h3><ul><li>伪造语音检测领域内规模最大、最全面的挑战赛，是由英国爱丁堡大学、法国EURECOM、日本NEC、东芬兰大学等多个研究机构共同组织发起的两年一度的<strong>ASVspoof 挑战赛(Automatic Speaker VerificationSpoofing And Countermeasures Challenge)</strong></li><li>该赛事旨在通过发布公开数据集并组织竞争性评估来促进ASV伪造语音检测技术的发展</li></ul><h3 id="5-相关数据集"><a href="#5-相关数据集" class="headerlink" title="5 相关数据集"></a>5 相关数据集</h3><ul><li><img src="/img/语音伪造及检测技术研究综述/11.png" alt=""></li></ul><h4 id="5-1-ASVspoof挑战赛数据集"><a href="#5-1-ASVspoof挑战赛数据集" class="headerlink" title="5.1 ASVspoof挑战赛数据集"></a>5.1 ASVspoof挑战赛数据集</h4><ul><li>ASVspoof2015数据集是第一个用于伪造和检测研究的主要数据集，仅针对LA场景，由真实语音和合成/转换语音组成</li><li>ASVspoof2019有LA和PA两个子集，LA子集包含真实和合成/转换语音，PA子集包含真实和重放语音，在一个模拟且可控的声学环境中创建，以控制重放语音中的非受控音素</li></ul><h4 id="5-2-AVspoof数据集"><a href="#5-2-AVspoof数据集" class="headerlink" title="5.2 AVspoof数据集"></a>5.2 AVspoof数据集</h4><ul><li>包含合成、转换、重放三种伪造攻击</li><li>测试集中引入了未知重放攻击</li></ul><h3 id="6-工具资源及相关源代码"><a href="#6-工具资源及相关源代码" class="headerlink" title="6 工具资源及相关源代码"></a>6 工具资源及相关源代码</h3><ul><li><img src="/img/语音伪造及检测技术研究综述/12.png" alt=""></li><li><img src="/img/语音伪造及检测技术研究综述/13.png" alt=""></li></ul><h3 id="7-伪造语音检测未来研究方向"><a href="#7-伪造语音检测未来研究方向" class="headerlink" title="7 伪造语音检测未来研究方向"></a>7 伪造语音检测未来研究方向</h3><ol><li>高泛化性检测<ul><li>依赖特定数据集或伪造方法的<u>训练数据种类单一且同分布</u>，泛化能力较弱</li><li>未来应进一步探索有效的<u>多角度深度融合特征</u>以及有效的<u>集成算法</u></li></ul></li><li>少样本检测<ul><li>现有的伪造语音检测大都依赖于大规模、高质量的深度伪造数据集</li><li>未来应更多地探索基于小样本的自监督学习等技术，保证检测效果的前提下，有效降低模型训练成本</li></ul></li><li>鲁棒检测<ul><li>现有的伪造语音检测方法容易在训练集上过拟合，对经过重压缩、加噪等处理后的语音检测鲁棒性较差</li><li>未来应探索鲁棒的检测算法，<u>如利用对抗样本对检测模型进行对抗训练</u>，或<u>在模型建立的不同阶段，探索不同预处理方法对检测算法鲁棒性的影响</u></li></ul></li><li>活体特征检测<ul><li>现有伪造语音绝大多数没有底噪和背景杂音，但真实语音存在录音底噪、环境噪声、喷麦等</li><li>未来应将上述活体特征作为辅助信息</li></ul></li><li>多模态检测<ul><li>现有的多媒体伪造视频大多通过画面和语音结合以达到更逼真的伪造效果</li><li>未来应探索伪造数据的多模态检测</li></ul></li><li>特定说话人风格检测<ul><li>现有的伪造语音检测方法可以以高自然度模拟目标说话人的音色，但往往忽视了其独特灵活的口语语言特征，如口头禅、赘语、口音、发音习惯等</li><li>未来应探究特定说话人的语言风格，捕捉能体现说话人个体言语特点的有效特征,以便检测音频真伪</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>文献笔记</category>
      
      <category>音频安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>音频安全</tag>
      
      <tag>文献笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>音频安全</title>
    <link href="/2022/10/09/%E9%9F%B3%E9%A2%91%E5%AE%89%E5%85%A8/"/>
    <url>/2022/10/09/%E9%9F%B3%E9%A2%91%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-音频分析"><a href="#1-音频分析" class="headerlink" title="1 音频分析"></a>1 音频分析</h2><h3 id="1-1-时域信号分析"><a href="#1-1-时域信号分析" class="headerlink" title="1.1 时域信号分析"></a>1.1 时域信号分析</h3><ul><li><p>虽然音频信号具有时变特性，但是在短时间范围内，其特性保持不变，可以将其看作是准稳态过程，即语音具有<strong>短时平稳性</strong></p></li><li><p>时域分析就是分析和提取音频信号的时域参数，采用时域波形图，如下图</p><p><img src="/img/%E9%9F%B3%E9%A2%91%E5%AE%89%E5%85%A8/1.png"></p></li><li><p>特点：</p><ul><li>表示音频信号直观、物理意义明确</li><li>实现起来简单、运算少</li><li>可以得到音频的一些重要参数</li><li>只使用示波器等通用设备，使用较为简单</li></ul></li><li><p>时域参数有<strong>短时能量、短时过零率、短时白相关函数</strong>和<strong>短时平均幅度差函数</strong>等，这是音频信号的一组最基本的短时参数</p><ol><li><p>短时能量和短时平均幅度</p><ul><li><p>短时能量可以作为区分清音段和浊音段的依据</p></li><li><p>浊音段的短时能量明显高于清音段</p></li><li><p>在信噪比高的情况下，还可以区分有声无声</p></li><li><p>$$<br>E_n&#x3D;\sum_{m&#x3D;-∞}^{∞}{[x(m)w(n-m)]^2}&#x3D;\sum_{m&#x3D;n-N+1}^{n}{[x(m)w(n-m)]^2}</p><p>\w(n)是窗函数，N是窗的长度<br>$$</p></li></ul></li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>音频安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>音频分析</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息隐藏_Chapter1</title>
    <link href="/2022/09/13/%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F-Chapter1/"/>
    <url>/2022/09/13/%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F-Chapter1/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章-概论"><a href="#第一章-概论" class="headerlink" title="第一章 概论"></a>第一章 概论</h2><h3 id="1-1-什么是信息隐藏"><a href="#1-1-什么是信息隐藏" class="headerlink" title="1.1 什么是信息隐藏"></a>1.1 什么是信息隐藏</h3><ul><li><p>信息隐藏是一门体现人类高度智慧的信息安全斗争技术和艺术</p></li><li><p>所谓信息隐藏就是将秘密信息秘密地隐藏于另一非机密的文件内容之中，比如图像、声音…</p></li><li><p>信息隐藏的载体作用体现在两方面：</p><ul><li>提供传递信息的信道</li><li>为隐藏信息的传递提供伪装</li></ul></li><li><p>信息隐藏和密码技术的区别</p><ul><li>密文的秘密信息不可懂</li><li>信息隐藏的秘密信息<strong>不可见</strong></li></ul></li><li><p>隐写术：通过对载体进行难以被感知的改动，从而<strong>嵌入与载体无关的秘密信息</strong>的技术</p></li><li><p>数字水印：通过对载体进行难以被感知的改动，从而<strong>嵌入与载体有关信息</strong>的技术</p></li><li><p>隐写分析：检测、提取、破坏隐写对象中秘密信息的技术</p></li><li><table><thead><tr><th></th><th>隐写术</th><th>数字水印</th></tr></thead><tbody><tr><td>保护对象</td><td>保护嵌入到载体中的秘密信息</td><td>隐藏信息的载体</td></tr><tr><td>不可察觉性</td><td>√</td><td>-</td></tr><tr><td>不可检测性</td><td>√</td><td>-</td></tr><tr><td>隐藏容量</td><td>√</td><td>-</td></tr><tr><td>鲁棒性</td><td>-</td><td>√（脆弱水印除外）</td></tr><tr><td>不可见</td><td>√</td><td>也有可见水印</td></tr></tbody></table></li></ul><h3 id="1-2-信息隐藏的历史回顾"><a href="#1-2-信息隐藏的历史回顾" class="headerlink" title="1.2 信息隐藏的历史回顾"></a>1.2 信息隐藏的历史回顾</h3><h4 id="1-2-1-技术性的隐写术"><a href="#1-2-1-技术性的隐写术" class="headerlink" title="1.2.1 技术性的隐写术"></a>1.2.1 技术性的隐写术</h4><ul><li>纹头送信、书记板、实物隐藏、标记法、微缩胶片法、化学方法、艺术作品、回声法、嵌入隐匿标记</li></ul><h4 id="1-2-2-语言学中的隐写术"><a href="#1-2-2-语言学中的隐写术" class="headerlink" title="1.2.2 语言学中的隐写术"></a>1.2.2 语言学中的隐写术</h4><ul><li>诗情画意传“密语”（藏头诗）、首字母（次字母）法，卡登格子法、乐谱法</li></ul><h4 id="1-2-3-保护版权的隐写术"><a href="#1-2-3-保护版权的隐写术" class="headerlink" title="1.2.3 保护版权的隐写术"></a>1.2.3 保护版权的隐写术</h4><ul><li>核对校验图、纸张中的水印、纸币中的水印</li></ul><h3 id="1-3-发展现状和分类"><a href="#1-3-发展现状和分类" class="headerlink" title="1.3 发展现状和分类"></a>1.3 发展现状和分类</h3><h4 id="1-3-1-信息隐藏技术的发展现状"><a href="#1-3-1-信息隐藏技术的发展现状" class="headerlink" title="1.3.1 信息隐藏技术的发展现状"></a>1.3.1 信息隐藏技术的发展现状</h4><ul><li>92年国际上正式提出信息隐形研究</li><li>96年国际第一届信息隐藏研讨会（IHW）</li><li>99年中国第一届信息隐藏研讨会（CIHW）</li><li>隐写术和数字水印的研究现状：<ul><li>正向研究：基于图像的较成熟，基于音频的有待发展，视频隐写和数字水印是新兴研究热点</li><li>逆向研究：<ul><li>主动攻击：在不显著影响使用价值前提下，尽量抹除信息</li><li>被动攻击：判定并提取待检测载体中信息</li><li>新研究点：Benchmark，数字图像取证，感知哈希</li><li>理论研究：容量研究（博弈法、信息论法）</li></ul></li></ul></li><li>文献检索关键词：<ul><li>Information Hiding 信息隐藏</li><li>Steganography 隐写</li><li>Steganalysis 隐写分析</li><li>Digital Watermarking 数字水印</li></ul></li><li>信息隐藏研究分支：<ul><li><strong>隐写术：伪装式保密通信</strong></li><li><strong>数字水印：数字产品版权保护</strong></li><li>信息分存：可视密码</li><li>隐蔽信道：计算机系统中的一些通道</li><li>数字图像取证：真实性鉴别</li></ul></li></ul><h4 id="1-3-2-伪装式保密通信"><a href="#1-3-2-伪装式保密通信" class="headerlink" title="1.3.2 伪装式保密通信"></a>1.3.2 伪装式保密通信</h4><ul><li>伪装式保密通信是古典隐写术与现代技术的直接结合</li><li>隐藏载体：多媒体信息（图像、视频、音频以及文本）</li><li>可视密码学：把隐藏的密钥信息通过算法隐藏到两个或多个子密钥图片中，每一张图片上都有随机分布的黑点和白点，把所有图片叠加在一起，则能恢复出原有信息</li><li>叠像术：每张子密钥图片不再是随机噪声图像，而是有文字或图画的正常图像，只有将一定数量的图像叠加在一起，每一张图像的内容都将消失，显现出被隐藏内容（理论上证明不可破译）</li></ul><h4 id="1-3-3-数字水印"><a href="#1-3-3-数字水印" class="headerlink" title="1.3.3 数字水印"></a>1.3.3 数字水印</h4><ul><li>用于<strong>版权保护</strong>的数字水印<ul><li>将版权所有者信息作为数字水印，嵌入在要保护的数字多媒体作品中，防止其他团体对该作品宣称拥有版权</li><li>具有不可察觉性、稳健性、唯一性等要求</li><li>抵抗一些正常的数据处理和恶意的攻击</li></ul></li><li>用于<strong>盗版跟踪</strong>的数字指纹<ul><li>数字水印代表产品的作者信息，<strong>数字指纹主要指产品购买者的信息</strong></li><li>每个用户买到的复件中，都预先被嵌入了包含购买者信息的数字指纹，用于跟踪和监控产品在市场上的非法复制</li><li>数字指纹除了具有数字水印的普遍特性外，还应该能够抵抗共谋攻击</li></ul></li><li>用于<strong>复制保护</strong>的数字水印<ul><li>对于嵌入了数字水印的产品，经正常授权的用户可以无障碍使用，非授权用户（或非法复制、盗版的产品）无法正常使用产品</li><li>某些应用中，复制保护可以实现</li></ul></li></ul><h3 id="1-4-信息隐藏算法性能指标"><a href="#1-4-信息隐藏算法性能指标" class="headerlink" title="1.4 信息隐藏算法性能指标"></a>1.4 信息隐藏算法性能指标</h3><ol><li>透明性<ul><li>也称不可感知性，是指嵌入的秘密信息导致隐写载体信号质量变化的程度，即在被保护信息中嵌入数字水印后应不引起原宿主媒体质量的显著下降和视听觉效果的明显变化</li></ul></li><li>鲁棒性<ul><li>也称稳健性，是指隐藏的秘密信息抵抗各种信号处理和攻击的能力</li></ul></li><li>隐藏容量<ul><li>指在单位时间或一副作品中能嵌入水印的比特数<ul><li>图片：嵌入在此幅图像中的所有比特数</li><li>音频：一秒传输过程中所嵌入秘密信息的比特数</li><li>视频：每一帧&#x2F;每一秒中嵌入的比特数</li></ul></li></ul></li></ol><ul><li>三个性能指标相互制约<ul><li>透明性好，鲁棒性往往差</li><li>鲁棒性好，透明性比较差</li><li>容量大时，透明性比较差</li></ul></li><li><img src="/img/%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F-Chapter1/image-20220912104023013.png"></li></ul><h3 id="1-5-可视密码学"><a href="#1-5-可视密码学" class="headerlink" title="1.5 可视密码学"></a>1.5 可视密码学</h3><ul><li>依靠人眼解密的秘密共享方法：将一个秘密图像<strong>加密成n张分享图像</strong>，分别由n个人保管，解密时只需k’(k’≥k)个人将各自的分享图像叠加，秘密图像就会呈现，而<strong>少于k个人无法获得</strong>秘密图像的任何一点信息。<ul><li>密文为图像</li><li>直接由人类视觉解密，不需具备密码学相关知识</li><li>拓展形式：像素不扩展型，叠像术，防止欺骗性等</li></ul></li><li>灰度图像可视密码技术<ul><li>半色调技术：将连续调图像转换成黑白图像的方法（通过黑点的疏密来模拟颜色的浓淡）</li><li>误差扩散法：先阈值量化图像像素，将量化过程中产生的误差分配给周围像素点<ul><li>输入像素值≤127（比较接近黑色)，输出0（黑色）</li><li>输入＞127（比较接近白色），输出255（白色）</li><li>误差&#x3D;输入-输出</li><li>将误差扩散到4个待处理的邻点：右、右下、正下、左下</li></ul></li></ul></li><li>彩色图像可视密码技术<ul><li>将彩色图像的每个分量（红、绿、蓝）当作一张图片（即三张图片），对每张图片按照“灰度图像”进行半色调处理，然后对每张图片进行信息分存</li><li>R、G、B分别分存到两张子图中，最后将得到的子图合并可以得到两张彩色子图</li></ul></li></ul><h3 id="1-6-叠像术"><a href="#1-6-叠像术" class="headerlink" title="1.6 叠像术"></a>1.6 叠像术</h3><ul><li><p>二值图像</p><ul><li><p>既能隐藏原密钥，不为密码分析所攻破，又能使子密钥“可读”</p></li><li><p>只有足够数目的子密钥叠加，每个子密钥上的明文消失，被隐藏的原密钥出现</p></li><li><p>在可视密码学基础上，需要再找两张图片（尺寸一样）进行子图的隐藏</p><ul><li><p>有8种情况</p><p><img src="/img/%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F-Chapter1/image-20220912112010148.png"></p></li><li><p>（2，2）信息分存方案<img src="/img/%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F-Chapter1/image-20220912111755769.png"></p><p><img src="/img/%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F-Chapter1/image-20220912112242316.png"></p></li></ul></li><li><p>原始图像—&gt;二值图像—&gt;分存到两个子图—&gt;叠加恢复原图</p></li></ul></li><li><p>灰度图像</p><ul><li>半色调处理成二值图像，得到的像素点只有0和255两个，可以将255视为二值图像的“1”，进行类似的二值化处理</li><li>信息分存与二值图像一致</li></ul></li><li><p>彩色图像</p><ul><li>再找两张彩色图片，对三张进行半色调处理，方法参考可视密码技术</li><li>对处理后的图片，把R、G、B每个分量看出一张图片，按照灰度图像叠像术技术进行处理</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>信息隐藏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息隐藏</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统_Chapter3</title>
    <link href="/2022/09/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Chapter3/"/>
    <url>/2022/09/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Chapter3/</url>
    
    <content type="html"><![CDATA[<h2 id="第3章-进程描述和控制"><a href="#第3章-进程描述和控制" class="headerlink" title="第3章 进程描述和控制"></a>第3章 进程描述和控制</h2><ul><li>操作系统的多数需求都涉及进程：<ul><li>与普通计算机软件作用相同，是由处理器执行的一段程序或一组程序</li><li>必须交替执行多个进程，在合理的响应时间范围内使处理器的利用率最大</li><li>必须按照特定的策略给进程分配资源，同时避免死锁</li><li>为有助于构建应用的进程间通信和用户进程创建提供支持</li></ul></li></ul><h3 id="3-1-什么是进程"><a href="#3-1-什么是进程" class="headerlink" title="3.1 什么是进程"></a>3.1 什么是进程</h3><h4 id="3-1-1-背景"><a href="#3-1-1-背景" class="headerlink" title="3.1.1 背景"></a>3.1.1 背景</h4><ul><li>操作系统需要达到的目标：<ul><li>资源对多个应用程序可用</li><li>处理器在多个程序间切换，保证所有程序都在执行中</li><li>处理器和I&#x2F;O设备得到充分利用</li></ul></li></ul><h4 id="3-1-2-进程和进程控制块"><a href="#3-1-2-进程和进程控制块" class="headerlink" title="3.1.2 进程和进程控制块"></a>3.1.2 进程和进程控制块</h4><ul><li>进程的几个定义：<ul><li>一个正在执行的程序</li><li>一个正在计算机上执行的程序实例</li><li>能分配给处理器并由处理器执行的实体</li><li>由一组执行的指令、一个当前状态和一组相关的系统资源表征的活动单元</li></ul></li><li>进程&#x3D;程序+执行，可由如下元素表征：<ul><li>标识符</li><li>状态</li><li>优先级</li><li>程序计数器（PC）</li><li>内存指针</li><li>上下文数据</li><li>I&#x2F;O状态信息</li><li>记账信息（处理器时间总和、使用的时钟数总和等）</li></ul></li><li><strong>进程控制块（process control block，PCB）</strong>：保存上述列表信息，由操作系统创建和管理</li></ul><h3 id="3-2-进程状态"><a href="#3-2-进程状态" class="headerlink" title="3.2 进程状态"></a>3.2 进程状态</h3><ul><li>列出为进程执行的指令序列，可描述单个进程的行为，这样的序列称为进程<strong>轨迹（trace）</strong></li><li>分派器（scheduler）：使处理器切换进程</li></ul><h4 id="3-2-1-两状态进程模型"><a href="#3-2-1-两状态进程模型" class="headerlink" title="3.2.1 两状态进程模型"></a>3.2.1 两状态进程模型</h4><ul><li><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Chapter3/image-20220910100055215.png"></li><li>进程被分为运行态和非运行态</li><li><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Chapter3/image-20220910100118292.png"></li><li>用排队图描述分派器的行为：当一个处于运行态的进程终止后，我们就要选一个处于非运行态的进程进入运行态</li></ul><h4 id="3-2-2-进程的创建和终止"><a href="#3-2-2-进程的创建和终止" class="headerlink" title="3.2.2 进程的创建和终止"></a>3.2.2 进程的创建和终止</h4><ul><li><p><strong>进程的创建</strong>：操作系统建立用于管理该进程的数据结构，并在内存中分配地址空间</p></li><li><p>创建进程的原因：</p><table><thead><tr><th>事件</th><th>说明</th></tr></thead><tbody><tr><td>新的批处理作业</td><td>磁带中的批处理作业控制流通常会提供给操作系统，当操作系统准备接收新工作时，将读取下一个作业控制命令</td></tr><tr><td>交互登录</td><td>终端用户登录到系统</td></tr><tr><td>为提供服务</td><td>操作系统创建一个进程，代表用户程序执行一个功能，使用户无需等待</td></tr><tr><td>由现有进程派生</td><td>基于模块化的考虑或开发并行性，用户程序可以指示创建多个进程</td></tr></tbody></table></li><li><p><strong>进程派生（process spawing）</strong>：操作系统为另一个进程显式请求创建一个进程的动作。（原进程为父进程，被派生的进程为子进程）</p></li><li><p><strong>进程终止</strong>：操作系统发出一个服务请求，以终止发出请求的进程。</p></li><li><p>导致进程终止的原因：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">正常完成超过时限无可用内存超出范围保护错误<br>算术错误时间超出<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>失败  无效指令  特权指令<br>数据误用操作员或操作系统干涉父进程终止父进程请求<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-2-3-五状态模型"><a href="#3-2-3-五状态模型" class="headerlink" title="3.2.3 五状态模型"></a>3.2.3 五状态模型</h4><ul><li><p>两状态的问题：存在一些处于非运行态但已就绪等待执行的进程，也存在一些处于阻塞态等待I&#x2F;O操作结束的进程</p></li><li><p>因此，若使用单个队列，分派器不能只考虑选择队列中最老的进程，而是扫描列表，查找未被阻塞且在队列中时间最长的进程</p></li><li><p>办法：将非运行态分成两个状态：<strong>就绪态（ready）</strong>和<strong>阻塞态（blocked）</strong></p></li><li><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Chapter3/image-20220910100136847.png"></p><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>运行态</td><td>进程正在执行</td></tr><tr><td>就绪态</td><td>进程已准备好，只要有机会就开始执行</td></tr><tr><td>阻塞&#x2F;等待态</td><td>进程在某些事件发生前不能执行</td></tr><tr><td>新建态</td><td>刚刚创建的进程，还未加入到可执行进程组（进程控制块已创建但还未加载到内存中的新进程）</td></tr><tr><td>退出态</td><td>从可执行进程组释放出的进程（自身停止或被取消）</td></tr></tbody></table></li></ul><h4 id="3-2-4-被挂起的进程"><a href="#3-2-4-被挂起的进程" class="headerlink" title="3.2.4 被挂起的进程"></a>3.2.4 被挂起的进程</h4><ul><li><p>交换：把内存中某个进程的一部分或全部移到磁盘中，当内存中不存在就绪态的进程时，操作系统就把被阻塞的进程换到磁盘中的挂起队列（suspend queue）</p></li><li><p><strong>挂起态（suspend）</strong>：内存中所有进程都处于阻塞态时，操作系统可把其中的一个进程置为挂起态，并把它转移到磁盘，此时内存所释放的空间就可被调入的另一个进程使用</p></li><li><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Chapter3/image-20220910100148367.png"></p><ul><li>就绪态：进程已在内存中并可以执行</li><li>阻塞态：进程已在内存中并等待一个事件</li><li>阻塞&#x2F;挂起态：进程已在外存中并等待一个事件</li><li>就绪&#x2F;挂起态：进程已在外存中，但只要载入内存就可执行</li></ul></li><li><p>进程挂起的原因：</p><table><thead><tr><th>事件</th><th>说明</th></tr></thead><tbody><tr><td>交换</td><td>操作系统需要释放足够的内存空间，以调入并执行处于就绪态的进程</td></tr><tr><td>其他OS原因</td><td>操作系统可能挂起后台进程或工具程序进程，或挂起可能会导致问题的进程</td></tr><tr><td>交互式用户请求</td><td>用户希望挂起一个程序的执行，以便调试或关联资源的使用</td></tr><tr><td>定时</td><td>进程可被周期性地执行，并在等待下一个时间间隔时挂起</td></tr><tr><td>父进程请求</td><td>父进程可能会希望挂起后代进程的执行，以检查或修改挂起的进程，或协调不同后代进程之间的行为</td></tr></tbody></table></li></ul><h3 id="3-3-进程描述"><a href="#3-3-进程描述" class="headerlink" title="3.3 进程描述"></a>3.3 进程描述</h3><h4 id="3-3-1-操作系统的控制结构"><a href="#3-3-1-操作系统的控制结构" class="headerlink" title="3.3.1 操作系统的控制结构"></a>3.3.1 操作系统的控制结构</h4><ul><li>操作系统构造并维护四种信息表以掌握每个进程和资源的当前状态：内存、I&#x2F;O、文件和进程</li><li>**内存表（memory table)**：用于跟踪内存和外存。包含以下信息：<ul><li>分配给进程的内存</li><li>分配给进程的外存</li><li>内存块或虚存块的任何保护属性</li><li>管理虚存所需要的任何信息</li></ul></li><li><strong>I&#x2F;O表</strong>：管理计算机系统中的I&#x2F;O设备和通道：</li><li><strong>文件表（file table）</strong>：提供关于文件是否存在、文件在外存中的位置、当前状态和其他属性的信息</li><li><strong>进程表（process tables）</strong>：必须有对内存、I&#x2F;O、文件的直接或间接引用</li></ul><h4 id="3-3-2-进程控制结构"><a href="#3-3-2-进程控制结构" class="headerlink" title="3.3.2 进程控制结构"></a>3.3.2 进程控制结构</h4><ul><li><p><strong>进程映像（process image）</strong>：程序、数据、栈和属性（PCB）的集合</p><table><thead><tr><th>元素</th><th>说明</th></tr></thead><tbody><tr><td>用户数据</td><td>可修改的部分，包括程序数据、用户栈区域和可修改的程序</td></tr><tr><td>用户程序</td><td>待执行的程序</td></tr><tr><td>栈</td><td>每个进程有至少一个后进先出栈，用于保存参数、过程调用地址和系统调用地址</td></tr><tr><td>进程控制块</td><td>操作系统控制进程所需的数据</td></tr></tbody></table></li><li><p>进程控制块信息分为三类：</p><ul><li>进程标识信息</li><li>进程状态信息</li><li>进程控制信息</li></ul></li><li><p>对所有操作系统中的<strong>进程标识符（process identification）</strong>来说，每个进程都分配了一个唯一的数字标识符，包括：</p><ul><li>该进程的标识符（Process ID）</li><li>父进程的标识符</li><li>用户标识符（User ID）</li></ul></li><li><p><strong>处理器状态信息（processor state information）</strong>由处理器寄存器的内容组成，通常包括：</p><ul><li>用户可见寄存器：用户模式下执行时可访问的寄存器</li><li>控制和状态寄存器：程序计数器、<strong>程序状态字（Program State Word，PSW）</strong>（通常包含条件码、状态信息）</li><li>栈指针：指向栈顶</li></ul></li><li><p><strong>进程控制信息（process control information）</strong>是操作系统控制和协调各种活动进程所需要的额外信息</p><ul><li>调度和状态信息：进程状态、优先级、调度相关信息、事件</li><li>数据结构：进程可以以队列等结构链接到其他进程</li><li>进程间通信</li><li>进程特权</li><li>存储管理</li><li>资源所有权和使用情况</li></ul></li><li><p>进程控制块的作用：操作系统中最重要的数据结构。每个PCB都包含操作系统所需进程的所有信息</p></li></ul><h3 id="3-4-进程控制"><a href="#3-4-进程控制" class="headerlink" title="3.4 进程控制"></a>3.4 进程控制</h3><h4 id="3-4-1-执行模式"><a href="#3-4-1-执行模式" class="headerlink" title="3.4.1 执行模式"></a>3.4.1 执行模式</h4><ul><li><p><strong>用户模式（user model）</strong>：非特权模式</p></li><li><p><strong>系统&#x2F;控制&#x2F;内核模式（kernel model）</strong>：特权模式</p></li><li><p>操作系统内核的典型功能：</p><table><thead><tr><th>功能</th><th>具体</th></tr></thead><tbody><tr><td>进程管理</td><td>①进程的创建和终止②进程的调度和分派③进程切换④进程同步和进程间通信的支持⑤管理进程控制块</td></tr><tr><td>内存管理</td><td>①为进程分配空间②交换③页和段管理</td></tr><tr><td>I&#x2F;O管理</td><td>①缓冲器管理②为进程分配I&#x2F;O通道和设备</td></tr><tr><td>支持功能</td><td>①中断处理②记账③监视</td></tr></tbody></table></li></ul><h4 id="3-4-2-进程创建"><a href="#3-4-2-进程创建" class="headerlink" title="3.4.2 进程创建"></a>3.4.2 进程创建</h4><ul><li>创建进程的步骤：<ol><li>分配一个唯一的进程标识符</li><li>分配空间（包括进程映像中所有元素）</li><li>初始化PCB</li><li>设置正确的链接（放置就绪或就绪&#x2F;挂起链表中）</li><li>创建或扩充其他数据结构</li></ol></li></ul><h4 id="3-4-3-进程切换"><a href="#3-4-3-进程切换" class="headerlink" title="3.4.3 进程切换"></a>3.4.3 进程切换</h4><ul><li><p>进程执行的中断机制：</p><table><thead><tr><th>机制</th><th>原因</th><th>用途</th></tr></thead><tbody><tr><td>中断</td><td>来自当前执行指令的外部</td><td>对异步外部事件的反应</td></tr><tr><td>陷阱</td><td>与当前执行指令相关</td><td>处理一个错误或一个异常条件</td></tr><tr><td>系统调用</td><td>显式请求</td><td>调用操作系统函数</td></tr></tbody></table></li><li><p>中断：</p><ul><li>时钟中断：当前运行进程的执行时间超过最大允许切换时间段（时间片time slice）<ul><li>进程切换到就绪态，调入另一进程</li></ul></li><li>I&#x2F;O中断：是否发生I&#x2F;O活动<ul><li>若I&#x2F;O活动是一个或多个进程正在等待的事件，操作系统把所有阻塞态转换为就绪态</li></ul></li><li>内存失效：处理器遇到一个引用不在内存中的字的虚存地址，操作系统需要从外存把包含这一引用的内存块调入内存<ul><li>内存失效的进程进入阻塞态；操作系统切换进程，恢复另一进程的执行。等期望的块调入后，该进程置为就绪态</li></ul></li></ul></li><li><p>陷阱（trap）：操作系统确定错误或异常条件是否致命</p><ul><li>致命时，当前正运行进程置为退出态，并切换进程</li></ul></li><li><p>系统调用（supervisor call）：系统调用时会将用户进程置为阻塞态</p></li><li><p>中断发生后并不一定进行进程切换，只是保存处理器状态信息，在控制权返回给该程序时恢复这些信息。</p></li><li><p>进程状态的变化：</p><ul><li>模式切换可在不改变运行态进程的状态下发生</li><li>进程转换发生时，环境会发生实质性变化：<ol><li>保存处理器上下文</li><li>更新当前处于运行态进程的PCB（包括状态转换、退出原因）</li><li>把该进程的PCB移到相应的队列</li><li>选择另一个进程执行</li><li>更新所选进程的PCB</li><li>更新内存管理数据结构</li><li>载入PC和其他寄存器先前的值</li></ol></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统_Chapter2</title>
    <link href="/2022/09/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Chapter2/"/>
    <url>/2022/09/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Chapter2/</url>
    
    <content type="html"><![CDATA[<h2 id="第2章-操作系统概述"><a href="#第2章-操作系统概述" class="headerlink" title="第2章 操作系统概述"></a>第2章 操作系统概述</h2><h3 id="2-1-操作系统的目标和功能"><a href="#2-1-操作系统的目标和功能" class="headerlink" title="2.1 操作系统的目标和功能"></a>2.1 操作系统的目标和功能</h3><ul><li>操作系统是控制应用程序执行的程序，是应用程序和计算机硬件间的接口</li><li>三个目标：<ul><li>方便：使计算机更易于使用（人机接口）</li><li>有效：以更有效的方式使用计算机系统资源（资源管理器）</li><li>扩展能力：在不妨碍服务的前提下，有效地开发、测试和引入新的系统功能（操作系统）</li></ul></li></ul><h4 id="2-1-1-作为用户-x2F-计算机接口的操作系统"><a href="#2-1-1-作为用户-x2F-计算机接口的操作系统" class="headerlink" title="2.1.1 作为用户&#x2F;计算机接口的操作系统"></a>2.1.1 作为用户&#x2F;计算机接口的操作系统</h4><ul><li>操作系统通常提供以下几个方面的服务：<ul><li><u>程序开发</u>：提供帮助程序员开发的工具和服务（编辑器和调试器）</li><li><u>程序运行</u>：为用户处理运行程序时的资源调度问题</li><li><u>I&#x2F;O设备访问</u>：提供操作I&#x2F;O设备的统一接口</li><li><u>文件访问控制</u>：可提供保护机制</li><li><u>系统访问</u>：提供对资源和数据的保护，以避免未授权用户的访问，同时解决资源竞争时的冲突问题</li><li><u>错误检测和响应</u>：提供响应以清除错误条件</li></ul></li></ul><h4 id="2-1-2-作为资源管理器的操作系统"><a href="#2-1-2-作为资源管理器的操作系统" class="headerlink" title="2.1.2 作为资源管理器的操作系统"></a>2.1.2 作为资源管理器的操作系统</h4><ul><li>操作系统作为控制机制的两方面不同：<ul><li>与普通计算机软件的作用相同，是由处理器执行的一段或一组程序</li><li>经常会释放控制，让其余就绪进程得到CPU以执行，而且必须依赖处理器恢复控制</li></ul></li><li>操作系统一部分在内存中，包括<strong>内核程序（kernel&#x2F;nucleus</strong>）（包含OS最常用功能，是核心）和当前正在使用的其他程序</li><li>OS决定何时使用I&#x2F;O设备、控制文件的访问和使用，并且决定在运行一个特定的用户程序时，可以分配多少处理器时间</li></ul><h4 id="2-1-3-操作系统的易扩展性"><a href="#2-1-3-操作系统的易扩展性" class="headerlink" title="2.1.3 操作系统的易扩展性"></a>2.1.3 操作系统的易扩展性</h4><ul><li>重要的操作系统要不断发展，原因如下：<ul><li>硬件升级和新型硬件的出现</li><li>新的服务</li><li>纠正错误</li></ul></li></ul><h3 id="2-2-操作系统的发展史"><a href="#2-2-操作系统的发展史" class="headerlink" title="2.2 操作系统的发展史"></a>2.2 操作系统的发展史</h3><h4 id="2-2-1-串行处理"><a href="#2-2-1-串行处理" class="headerlink" title="2.2.1 串行处理"></a>2.2.1 串行处理</h4><ul><li>程序员直接和计算机硬件打交道，没有操作系统</li><li>两个主要问题：<ul><li>调度：大多数装置使用硬拷贝登记表来预订机器时间，有时预订时间大于工作所需时间造成计算机闲置；有时出现问题来不及解决时间就到了</li><li>准备时间：称为作业的单个程序，在运行前的准备工作若发生了错误，用户只能从头开始，因此花费大量时间</li></ul></li></ul><h4 id="2-2-2-简单批处理系统"><a href="#2-2-2-简单批处理系统" class="headerlink" title="2.2.2 简单批处理系统"></a>2.2.2 简单批处理系统</h4><ul><li>使用一个<strong>监控程序（monitor）</strong>的软件，操作员把作业按顺序组织成批，放在输入设备上，供监控程序使用，每完成一个程序返回到监控程序，加载下一个程序</li><li>两个角度：<ul><li>监控程序角度：控制事件的顺序。大部分监控程序总是处于内存中并且可以执行，称为<strong>常驻监控程序（resident monitor）</strong>，其他部分包括一些实用程序和公用函数</li><li>处理器角度：“控制权交给作业”表示处理器当前取的和执行的都是用户程序中的指令；“控制权返回给监控程序”表示处理器当前从监控程序中取指令并执行（CPU在monitor和用户作业间的使用权限转换来看简单批处理）</li></ul></li><li>监控程序完成调度功能也改善了作业的准备时间，每个作业中的指令均以一种<strong>作业控制语言（Job Control Language，JCL）</strong>的基本形式给出</li><li>其他硬件功能：<ul><li>内存保护：用户程序运行时不能改变包含监控程序的内存区域</li><li>定时器：防止一个作业独占系统</li><li>特权指令：只能由监控程序执行（I&#x2F;O指令等）</li><li>中断</li></ul></li><li>内存保护和特权指令引出了运行模式的概念：<ul><li><strong>用户模式（user mode）</strong>：用户程序执行，部分内存区域受保护，特权指令不允许执行</li><li><strong>内核模式（kernel mode）</strong>：监控程序执行，可以执行特权指令，可以访问受保护内存</li></ul></li></ul><h4 id="2-2-3-多道批处理系统"><a href="#2-2-3-多道批处理系统" class="headerlink" title="2.2.3 多道批处理系统"></a>2.2.3 多道批处理系统</h4><ul><li>简单批处理的作业经常I&#x2F;O命令，一旦I&#x2F;O中断，若内存中只有一个用户作业，则CPU要等待</li><li><strong>多道程序设计（multiprogramming）&#x2F;多任务处理（multitasking）</strong>：内存空间容得下操作系统和多个用户程序，当一个作业需要等待I&#x2F;O时，处理器切换到另一个可能并不在等待I&#x2F;O的作业</li><li>需要注意的问题：<ul><li>内存管理：待运行的作业需要保存在内存中</li><li>调度：处理器决定运行哪个作业</li><li>资源竞争</li></ul></li></ul><h4 id="2-2-4-分时系统"><a href="#2-2-4-分时系统" class="headerlink" title="2.2.4 分时系统"></a>2.2.4 分时系统</h4><ul><li><p>多个用户分享处理器时间，该技术称为<strong>分时（time sharing）</strong></p></li><li><p>在分时系统中，多个用户可以通过终端同时访问系统，由操作系统控制每个用户程序在很短的时间内交替执行</p></li><li><p>多道批处理与分时的比较</p><table><thead><tr><th></th><th>多道批处理</th><th>分时</th></tr></thead><tbody><tr><td>主要目标</td><td>充分利用处理器</td><td>减小响应时间</td></tr><tr><td>操作系统指令源</td><td>作业控制语言命令（JCL）<br />作业提供的命令</td><td>终端键入的命令</td></tr></tbody></table></li><li><p><strong>时间片（time slicing）</strong>：在固定的时间间隔内，当前用户被抢占，另一个用户被载入的技术</p></li><li><p>也存在内存管理、访问控制、资源竞争的问题</p></li></ul><h3 id="2-3-主要成就"><a href="#2-3-主要成就" class="headerlink" title="2.3 主要成就"></a>2.3 主要成就</h3><ul><li>4个重要理论进展：<ul><li>进程</li><li>内存管理</li><li>信息保护和安全</li><li>调度和资源管理</li></ul></li></ul><h4 id="2-3-1-进程"><a href="#2-3-1-进程" class="headerlink" title="2.3.1 进程"></a>2.3.1 进程</h4><ul><li>程序设计出错的主要原因：<ul><li><u>不正确的同步</u>：例如不正确的信号机制</li><li><u>失败的互斥</u>：多个用户或程序试图同时访问一个共享资源时，互斥机制出错</li><li><u>不确定的程序操作</u>：程序调度顺序可能会影响某个特定程序的输出结果</li><li><u>死锁</u>：很可能有两个或多个程序相互挂起等待</li></ul></li><li>解决以上问题，需要一种系统级方法监控处理器中不同程序的执行，进程为此提供基础</li><li>进程的组成三部分：<ul><li>一段可执行的程序</li><li>程序所需要的相关数据（变量、工作空间、缓冲区等）</li><li>程序的执行上下文</li></ul></li><li><strong>执行上下文（execution context）</strong>&#x2F;<strong>进程状态（process state）</strong>：操作系统用来管理和控制进程所需的内部数据</li><li><strong>线程（thread）</strong>：一个分配了资源的进程可分解为多个并发的线程，这些线程相互协作执行，完成进程的工作</li></ul><h4 id="2-3-2-内存管理"><a href="#2-3-2-内存管理" class="headerlink" title="2.3.2 内存管理"></a>2.3.2 内存管理</h4><ul><li>5项存储器管理职责：<ul><li>进程隔离</li><li>自动分配和管理</li><li>支持模块化程序设计</li><li>保护和访问控制</li><li>长期存储</li></ul></li><li>使用<strong>虚存</strong>和<strong>文件系统</strong>机制满足上述要求<ul><li>文件系统：在一个有名称的对象（即文件file）中保存信息，实现长期存储</li><li>虚存（virtual memory）：允许程序以逻辑方式访问存储器，不考虑物理内存上的可用空间数量。</li><li>程序使用虚地址访问，虚地址将映射成真实的内存地址，如果访问的虚地址不在实际内存中，实际内存中的一部分内容将换到外存中，然后换入所需要的数据块。</li></ul></li></ul><h4 id="2-3-3-信息保护和安全"><a href="#2-3-3-信息保护和安全" class="headerlink" title="2.3.3 信息保护和安全"></a>2.3.3 信息保护和安全</h4><ul><li>四类安全和保护问题：<ul><li>可用性：保护系统不被中断</li><li>保密性：保护用户不能读取未授权访问的数据</li><li>数据完整性：保护数据不被未授权修改</li><li>认证：涉及用户身份的正确认证和消息或数据的合法性</li></ul></li></ul><h4 id="2-3-4-调度和资源管理"><a href="#2-3-4-调度和资源管理" class="headerlink" title="2.3.4 调度和资源管理"></a>2.3.4 调度和资源管理</h4><ul><li>考虑3个因素：<ul><li>公平性</li><li>有差别的响应性</li><li>有效性（最大吞吐量、最小响应时间、尽可能多用户）</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统_Chapter1</title>
    <link href="/2022/09/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Chapter1/"/>
    <url>/2022/09/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Chapter1/</url>
    
    <content type="html"><![CDATA[<h2 id="第1章-计算机系统概述"><a href="#第1章-计算机系统概述" class="headerlink" title="第1章 计算机系统概述"></a>第1章 计算机系统概述</h2><h3 id="1-1-基本构成"><a href="#1-1-基本构成" class="headerlink" title="1.1 基本构成"></a>1.1 基本构成</h3><ul><li>4个主要的结构化部件：<ul><li>处理器（Processor）</li><li>内存（Main memory）</li><li>输入&#x2F;输出模块（I&#x2F;O modules）</li><li>系统总线（System bus)</li></ul></li><li>CPU内部<ul><li>PC（Program Counter，程序计数器）：保存下一次要取的指令地址</li><li>IR（Instruction Register，指令寄存器）：保存取到的指令</li><li>AC（Accumulator，累加器）：保存计算产生的中间结果</li><li>MAR（Memory Address Register，存储器地址寄存器）：确定下一次读&#x2F;写的存储器地址</li><li>MBR（Memory Buffer Register，存储缓冲寄存器）：存放写入&#x2F;读出存储器的数据</li><li>IO&#x2F;AR（I&#x2F;O Address Register，输入&#x2F;输出地址寄存器）：确定一个特定I&#x2F;O设备</li><li>IO&#x2F;BR（I&#x2F;O Buffer Register，输入&#x2F;输出缓冲寄存器）：用于I&#x2F;O模块和处理器交换数据</li></ul></li></ul><h3 id="1-2-指令的执行"><a href="#1-2-指令的执行" class="headerlink" title="1.2 指令的执行"></a>1.2 指令的执行</h3><ul><li>处理器执行的程序有一组保存在存储器中的指令组成。</li><li>单个指令所需要的处理称为一个指令周期：取指阶段和执行阶段</li><li>所有指令和数据长度均为16位，使用16位的单元或字长组织存储器</li><li>指令格式有4位是操作码，最多有2的4次方（16）种不同操作码，定义了处理器执行的操作，后12位是访问的数据地址</li></ul><h3 id="1-3-中断"><a href="#1-3-中断" class="headerlink" title="1.3 中断"></a>1.3 中断</h3><ul><li>中断的分类：<ul><li>程序中断：在某些条件下由执行的结果产生（算术溢出、除数为0）</li><li>时钟中断：处理器内部的计时器产生</li><li>I&#x2F;O中断：由I&#x2F;O控制器产生，通知正常完成或错误条件</li><li>硬件失效中断：掉电或存储器奇偶校验错等故障发生</li></ul></li></ul><h4 id="1-3-1-中断和指令周期"><a href="#1-3-1-中断和指令周期" class="headerlink" title="1.3.1 中断和指令周期"></a>1.3.1 中断和指令周期</h4><ul><li>中断处理程序（interrupt handler）：外部设备的I&#x2F;O模块给处理器发送中断请求信号，处理器暂停当前程序的处理，转去处理服务于特定I&#x2F;O设备的程序。</li><li>为适应中断产生，指令周期中增加一个中断阶段</li><li>中断处理必须执行额外的指令以确定中断的性质和采用何种操作，与简单等待I&#x2F;O操作完成花费更多时间相比，中断能使I&#x2F;O操作与处理器并发执行，提高处理器效率。</li></ul><h4 id="1-3-2-中断处理"><a href="#1-3-2-中断处理" class="headerlink" title="1.3.2 中断处理"></a>1.3.2 中断处理</h4><ul><li>当I&#x2F;O设备完成一次I&#x2F;O操作时，发生下列<strong>硬件事件</strong>：<ul><li>设备给处理器发送中断信号</li><li>处理器结束当前指令的执行</li><li>处理器确认存在未响应中断，并给提交中断的设备发送确认信号</li><li>处理器保存从中断点恢复当前程序所需要的信息（把程序状态字PSW和PC压入控制栈）</li><li>根据中断，处理器加载新PC值</li></ul></li><li>新PC值意味处理器进行下一指令周期，控制权被转交到中断处理程序，执行以下<strong>软件操作</strong>：<ul><li>保存剩余的处理状态信息（PC、PSW、寄存器的内容保存到系统栈）</li><li>处理中断</li><li>恢复处理状态信息（被保存的寄存器值从栈中释放并恢复到寄存器中）</li><li>恢复旧PSW和PC</li></ul></li></ul><h4 id="1-3-3-多个中断"><a href="#1-3-3-多个中断" class="headerlink" title="1.3.3 多个中断"></a>1.3.3 多个中断</h4><ul><li>处理多个中断的两种方法：<ul><li>正在处理一个中断时，禁止再发生中断（对其他中断信号不响应，保持挂起）</li><li>定义中断优先级，允许高优先级打断低优先级中断的运行</li></ul></li><li>中断服务例程：Interrupt Service Routine，ISR</li></ul><h3 id="1-4-存储器的层次结构"><a href="#1-4-存储器的层次结构" class="headerlink" title="1.4 存储器的层次结构"></a>1.4 存储器的层次结构</h3><ul><li><p>存储器三个重要特性：价格、容量、访问时间</p></li><li><p><strong>存储器层次结构（memory hierarchy）</strong>：从上往下看，</p></li><li><table><thead><tr><th>层次</th><th>具体存储器</th></tr></thead><tbody><tr><td>板上存储器</td><td>寄存器—&gt;高速缓存—&gt;内存</td></tr><tr><td>板外存储器</td><td>磁盘、CD-ROM、CD-RW、DVD-RW、DVD-RAM、Blu-Ray</td></tr><tr><td>离线存储器</td><td>磁带</td></tr></tbody></table><p>从上往下：</p><ul><li>每“位”的价格递减</li><li>容量递增</li><li>存取时间递增</li><li>处理器访问存储器的频率递减</li></ul></li><li><p><strong>命中率（hit ratio）</strong>：对较快存储器（如高速缓存）的访问次数与对所有存储器的访问次数的比值。</p></li><li><p>板上存储器通常是易失性，采用半导体技术，数据表现形式为byte或word</p></li><li><p>非易失性外部存储器又称，二级存储器（secondary memory）或辅助存储器（auxiliary memory），数据存储形式为file或record</p></li></ul><h3 id="1-5-高速缓存"><a href="#1-5-高速缓存" class="headerlink" title="1.5 高速缓存"></a>1.5 高速缓存</h3><h4 id="1-5-1-动机"><a href="#1-5-1-动机" class="headerlink" title="1.5.1 动机"></a>1.5.1 动机</h4><ul><li>处理器速度提高快于存储器访问速度的提高</li><li>解决方法：在处理器和内存之间提供一个容量小且速度快的存储器，称为高速缓存（cache）</li></ul><h4 id="1-5-2-高速缓存原理"><a href="#1-5-2-高速缓存原理" class="headerlink" title="1.5.2 高速缓存原理"></a>1.5.2 高速缓存原理</h4><ul><li>高速缓存包含一部分内存数据的副本，当处理器读取存储器时：<ul><li>检查改字是否在高速缓存中</li><li>如果在，传递给处理器</li><li>如果不在，由固定数目的字节组成的一块内存数据读入高速缓存，再传递给处理器</li></ul></li><li>根据访问<strong>局部性原理（principle of locality）</strong>,位于被访问字附件的数据在近期被访问到的概率较大</li><li>内存的系统结构：<ul><li>由2^n个可寻址的字组成，每个字有唯一的n位地址</li><li>划分成固定的块（block），每块包含K个字，即共有M&#x3D;2^n&#x2F;K个块</li></ul></li><li>高速缓存的系统结构：<ul><li>有C个存储槽（slots&#x2F;lines），每个槽有K个字，槽的数量远小于存储器中块的数量（C&lt;&lt;M)</li><li>由于一个槽不能唯一或永久对应于一个块，每个槽中有个标签，标识当前存储的是哪个块</li></ul></li></ul><h4 id="1-5-3-高速缓存设计"><a href="#1-5-3-高速缓存设计" class="headerlink" title="1.5.3 高速缓存设计"></a>1.5.3 高速缓存设计</h4><ul><li><strong>高速缓存大小（cache size）</strong>：适当小的高速缓存会对性能产生明显的影响</li><li><strong>块大小（block size）</strong>：即高速缓存与内存之间的数据交换单位，当块大小从很小增长到很大时，由于局部性原理，命中率首先会增加；当块更大时，新近取到的数据被用到的可能性开始小于被疑出缓存的数据再次被用到的可能性，命中率开始降低。</li><li><strong>映射函数（mapping function）</strong>：确定这个块将占据哪个高速缓存单元</li><li><strong>置换算法（replacement algorithm）</strong>：选择置换那些在不久的将来被访问的可能性最小的块</li><li><strong>写策略（write policy）</strong>：规定何时发生存储器写操作<ul><li>每当块被更新后就发生写操作</li><li>只有当被置换时才发生写操作（会使内存处于过时状态）</li></ul></li></ul><h3 id="1-6-直接内存存取"><a href="#1-6-直接内存存取" class="headerlink" title="1.6 直接内存存取"></a>1.6 直接内存存取</h3><ul><li>可编程I&#x2F;O（programmed I&#x2F;O）<ul><li>处理器正在执行程序遇到一个与I&#x2F;O相关的指令时，通过给相应的I&#x2F;O模块发命令执行这个指令</li><li>不会中断处理器，处理器轮巡检查I&#x2F;O操作是否完成</li></ul></li><li>中断驱动I&#x2F;O（interrupt-driven I&#x2F;O）<ul><li>处理器给I&#x2F;O模块发送I&#x2F;O命令，然后处理器继续其他工作</li><li>当I&#x2F;O模块准备好与处理器交换数据时，打断处理器的执行并请求服务</li><li>处理器仍然主动干预在存储器和I&#x2F;O模块之间的数据传送</li></ul></li><li>直接内存存取（Direct Memory Access，DMA）<ul><li>DMA功能由系统总线中的一个独立模块完成，也可以并入一个I&#x2F;O模块中</li><li>处理器读或写一块数据时，给DMA模块产生一条命令，之后处理器继续其他工作</li><li>DMA模块直接与存储器交互，传送数据块，完成后向处理器发送中断信号。</li><li>只有在开始传送和结束时处理才会参与（两次中断）</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/09/08/hello-world/"/>
    <url>/2022/09/08/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
